
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">git.fractalqb.de/fractalqb/groph/adjmatrix.go (83.3%)</option>
				
				<option value="file1">git.fractalqb.de/fractalqb/groph/bitset.go (84.2%)</option>
				
				<option value="file2">git.fractalqb.de/fractalqb/groph/copy.go (68.8%)</option>
				
				<option value="file3">git.fractalqb.de/fractalqb/groph/graph.go (54.1%)</option>
				
				<option value="file4">git.fractalqb.de/fractalqb/groph/internal/test/d2graph.go (0.0%)</option>
				
				<option value="file5">git.fractalqb.de/fractalqb/groph/internal/util/slices.go (20.0%)</option>
				
				<option value="file6">git.fractalqb.de/fractalqb/groph/minspantree/kruskal.go (81.8%)</option>
				
				<option value="file7">git.fractalqb.de/fractalqb/groph/misc.go (87.5%)</option>
				
				<option value="file8">git.fractalqb.de/fractalqb/groph/paths.go (88.9%)</option>
				
				<option value="file9">git.fractalqb.de/fractalqb/groph/shortestpath/dijkstra.go (99.0%)</option>
				
				<option value="file10">git.fractalqb.de/fractalqb/groph/shortestpath/floyd_warshall.go (80.7%)</option>
				
				<option value="file11">git.fractalqb.de/fractalqb/groph/sliceofmap.go (85.1%)</option>
				
				<option value="file12">git.fractalqb.de/fractalqb/groph/traverse/traverse.go (68.0%)</option>
				
				<option value="file13">git.fractalqb.de/fractalqb/groph/tree.go (0.0%)</option>
				
				<option value="file14">git.fractalqb.de/fractalqb/groph/tsp/2opt.go (100.0%)</option>
				
				<option value="file15">git.fractalqb.de/fractalqb/groph/tsp/greedy.go (46.9%)</option>
				
				<option value="file16">git.fractalqb.de/fractalqb/groph/util/adapt.go (38.7%)</option>
				
				<option value="file17">git.fractalqb.de/fractalqb/groph/util/graphio.go (75.5%)</option>
				
				<option value="file18">git.fractalqb.de/fractalqb/groph/util/misc.go (0.0%)</option>
				
				<option value="file19">git.fractalqb.de/fractalqb/groph/util/readasundir.go (87.5%)</option>
				
				<option value="file20">git.fractalqb.de/fractalqb/groph/util/subgraph.go (0.0%)</option>
				
				<option value="file21">git.fractalqb.de/fractalqb/groph/util/writegv.go (58.9%)</option>
				
				<option value="file22">git.fractalqb.de/fractalqb/groph/visit.go (55.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package groph

import (
        "errors"
        "math"

        iutil "git.fractalqb.de/fractalqb/groph/internal/util"
)

type adjMx struct {
        ord VIdx
}

func (m *adjMx) Order() VIdx <span class="cov8" title="1">{ return m.ord }</span>

// AdjMxDbitmap implements WGbool as a bitmap based adjacency
// matrix. Compared to AdjMxbool, this sacrifices runtime performance
// for lesser memory usage.
type AdjMxDbitmap struct {
        adjMx
        bs bitSet
}

func NewAdjMxDbitmap(order VIdx, reuse *AdjMxDbitmap) *AdjMxDbitmap <span class="cov8" title="1">{
        sz := order * order
        sz = bitSetWords(sz)
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDbitmap{
                        adjMx: adjMx{ord: order},
                        bs:    make(bitSet, sz),
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.bs = iutil.U64Slice(reuse.bs, int(sz))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDbitmap) Init(flag bool) *AdjMxDbitmap <span class="cov8" title="1">{
        if flag </span><span class="cov0" title="0">{
                for i := range m.bs </span><span class="cov0" title="0">{
                        m.bs[i] = ^uint64(0)
                }</span>
        } else<span class="cov8" title="1"> {
                for i := range m.bs </span><span class="cov8" title="1">{
                        m.bs[i] = 0
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxDbitmap) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxDbitmap(order, m)
        m.Init(false)
}</span>

func (m *AdjMxDbitmap) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if m.Edge(u, v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDbitmap) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, false)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(bool))
        }</span>
}

func (m *AdjMxDbitmap) Edge(i, j VIdx) (w bool) <span class="cov8" title="1">{
        w = m.bs.get(m.ord*i + j)
        return w
}</span>

func (m *AdjMxDbitmap) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        if w </span><span class="cov8" title="1">{
                m.bs.set(m.ord*i + j)
        }</span> else<span class="cov8" title="1"> {
                m.bs.unset(m.ord*i + j)
        }</span>
}

type AdjMxDbool struct {
        adjMx
        bs []bool
}

func NewAdjMxDbool(order VIdx, reuse *AdjMxDbool) *AdjMxDbool <span class="cov8" title="1">{
        sz := order * order
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDbool{
                        adjMx: adjMx{ord: order},
                        bs:    make([]bool, sz),
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.bs = iutil.BoolSlice(reuse.bs, int(sz))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func AsAdjMxDbool(reuse *AdjMxDbool, weights []bool) (*AdjMxDbool, error) <span class="cov8" title="1">{
        sz, err := dOrdFromLen(len(weights))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reuse == nil </span><span class="cov8" title="1">{
                reuse = new(AdjMxDbool)
        }</span>
        <span class="cov8" title="1">reuse.ord = sz
        reuse.bs = weights
        return reuse, nil</span>
}

func (m *AdjMxDbool) Init(flag bool) *AdjMxDbool <span class="cov8" title="1">{
        for i := range m.bs </span><span class="cov8" title="1">{
                m.bs[i] = flag
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxDbool) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxDbool(order, m)
        m.Init(false)
}</span>

func (m *AdjMxDbool) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if m.Edge(u, v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDbool) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, false)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(bool))
        }</span>
}

func (m *AdjMxDbool) Edge(i, j VIdx) (w bool) <span class="cov8" title="1">{
        return m.bs[m.ord*i+j]
}</span>

func (m *AdjMxDbool) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        m.bs[m.ord*i+j] = w
}</span>

type AdjMxDi32 struct {
        adjMx
        ws  []int32
        del int32
}

func NewAdjMxDi32(order VIdx, del int32, reuse *AdjMxDi32) *AdjMxDi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDi32{
                        adjMx: adjMx{ord: order},
                        ws:    make([]int32, order*order),
                        del:   del,
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.ws = iutil.I32Slice(reuse.ws, int(order*order))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func AsAdjMxDi32(reuse *AdjMxDi32, del int32, weights []int32) (*AdjMxDi32, error) <span class="cov0" title="0">{
        sz, err := dOrdFromLen(len(weights))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if reuse == nil </span><span class="cov0" title="0">{
                reuse = new(AdjMxDi32)
        }</span>
        <span class="cov0" title="0">reuse.ord = sz
        reuse.ws = weights
        reuse.del = del
        return reuse, nil</span>
}

func (m *AdjMxDi32) Init(w int32) *AdjMxDi32 <span class="cov8" title="1">{
        for i := range m.ws </span><span class="cov8" title="1">{
                m.ws[i] = w
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxDi32) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxDi32(order, m.del, m)
        m.Init(m.del)
}</span>

func (m *AdjMxDi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        res, ok := m.Edge(u, v)
        if ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDi32) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, m.del)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(int32))
        }</span>
}

func (m *AdjMxDi32) Edge(i, j VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        w = m.ws[m.ord*i+j]
        return w, w != m.del
}</span>

func (m *AdjMxDi32) SetEdge(i, j VIdx, w int32) <span class="cov8" title="1">{
        m.ws[m.ord*i+j] = w
}</span>

type AdjMxDf32 struct {
        adjMx
        ws []float32
}

func NewAdjMxDf32(order VIdx, reuse *AdjMxDf32) *AdjMxDf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDf32{
                        adjMx: adjMx{ord: order},
                        ws:    make([]float32, order*order),
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.ws = iutil.F32Slice(reuse.ws, int(order*order))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func AsAdjMxDf32(reuse *AdjMxDf32, weights []float32) (*AdjMxDf32, error) <span class="cov0" title="0">{
        sz, err := dOrdFromLen(len(weights))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if reuse == nil </span><span class="cov0" title="0">{
                reuse = new(AdjMxDf32)
        }</span>
        <span class="cov0" title="0">reuse.ord = sz
        reuse.ws = weights
        return reuse, nil</span>
}

func (m *AdjMxDf32) Init(w float32) *AdjMxDf32 <span class="cov8" title="1">{
        for i := range m.ws </span><span class="cov8" title="1">{
                m.ws[i] = w
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxDf32) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxDf32(order, m)
        m.Init(NaN32())
}</span>

func (m *AdjMxDf32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        w := m.Edge(u, v)
        if math.IsNaN(float64(w)) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return w
        }</span>
}

func (m *AdjMxDf32) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.ws[m.ord*i+j] = nan32
        }</span> else<span class="cov8" title="1"> {
                m.ws[m.ord*i+j] = w.(float32)
        }</span>
}

func (m *AdjMxDf32) Edge(i, j VIdx) (w float32) <span class="cov8" title="1">{
        return m.ws[m.ord*i+j]
}</span>

func (m *AdjMxDf32) SetEdge(i, j VIdx, w float32) <span class="cov8" title="1">{
        m.ws[m.ord*i+j] = w
}</span>

type AdjMxUbool struct {
        adjMx
        ws []bool
}

func NewAdjMxUbool(order VIdx, reuse *AdjMxUbool) *AdjMxUbool <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUbool{
                        adjMx: adjMx{ord: order},
                        ws:    make([]bool, nSum(order)),
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.ws = iutil.BoolSlice(reuse.ws, int(nSum(order)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func AsAdjMxUbool(reuse *AdjMxUbool, weights []bool) (*AdjMxUbool, error) <span class="cov8" title="1">{
        sz, err := uOrdFromLen(len(weights))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reuse == nil </span><span class="cov8" title="1">{
                reuse = new(AdjMxUbool)
        }</span>
        <span class="cov8" title="1">reuse.ord = sz
        reuse.ws = weights
        return reuse, nil</span>
}

func (m *AdjMxUbool) Init(w bool) *AdjMxUbool <span class="cov8" title="1">{
        for i := range m.ws </span><span class="cov8" title="1">{
                m.ws[i] = w
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxUbool) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxUbool(order, m)
        m.Init(false)
}</span>

func (m *AdjMxUbool) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if m.Edge(u, v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxUbool) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{
        if m.EdgeU(u, v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxUbool) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(u, v, false)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(u, v, w.(bool))
        }</span>
}

func (m *AdjMxUbool) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdgeU(u, v, false)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdgeU(u, v, w.(bool))
        }</span>
}

func (m *AdjMxUbool) Edge(u, v VIdx) (w bool) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return m.ws[uIdx(u, v)]
        }</span>
        <span class="cov8" title="1">return m.ws[uIdx(v, u)]</span>
}

// EdgeU is used iff i &gt;= j
func (m *AdjMxUbool) EdgeU(u, v VIdx) (w bool) <span class="cov8" title="1">{ return m.ws[uIdx(u, v)] }</span>

func (m *AdjMxUbool) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                m.ws[uIdx(i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.ws[uIdx(j, i)] = w
        }</span>
}

// SetEdgeU is used iff i &gt;= j
func (m *AdjMxUbool) SetEdgeU(u, v VIdx, w bool) <span class="cov8" title="1">{ m.ws[uIdx(u, v)] = w }</span>

type AdjMxUi32 struct {
        adjMx
        ws  []int32
        del int32
}

func NewAdjMxUi32(order VIdx, del int32, reuse *AdjMxUi32) *AdjMxUi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUi32{
                        adjMx: adjMx{ord: order},
                        ws:    make([]int32, nSum(order)),
                        del:   del,
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.ws = iutil.I32Slice(reuse.ws, int(nSum(order)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func AsAdjMxUi32(reuse *AdjMxUi32, del int32, weights []int32) (*AdjMxUi32, error) <span class="cov0" title="0">{
        sz, err := uOrdFromLen(len(weights))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if reuse == nil </span><span class="cov0" title="0">{
                reuse = new(AdjMxUi32)
        }</span>
        <span class="cov0" title="0">reuse.ord = sz
        reuse.ws = weights
        reuse.del = del
        return reuse, nil</span>
}

func (m *AdjMxUi32) Init(w int32) *AdjMxUi32 <span class="cov8" title="1">{
        for i := range m.ws </span><span class="cov8" title="1">{
                m.ws[i] = w
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxUi32) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxUi32(order, m.del, m)
        m.Init(m.del)
}</span>

func (m *AdjMxUi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if w, ok := m.Edge(u, v); ok </span><span class="cov8" title="1">{
                return w
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxUi32) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{
        w, ok := m.EdgeU(u, v)
        if ok </span><span class="cov8" title="1">{
                return w
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxUi32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(u, v, m.del)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(u, v, w.(int32))
        }</span>
}

func (m *AdjMxUi32) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdgeU(u, v, m.del)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdgeU(u, v, w.(int32))
        }</span>
}

func (m *AdjMxUi32) Edge(u, v VIdx) (w int32, ok bool) <span class="cov8" title="1">{
        if u &gt;= v </span><span class="cov8" title="1">{
                w = m.ws[uIdx(u, v)]
        }</span> else<span class="cov8" title="1"> {
                w = m.ws[uIdx(v, u)]
        }</span>
        <span class="cov8" title="1">return w, w != m.del</span>
}

// EdgeU is used iff i &gt;= j
func (m *AdjMxUi32) EdgeU(u, v VIdx) (w int32, ok bool) <span class="cov8" title="1">{
        w = m.ws[uIdx(u, v)]
        return w, w != m.del
}</span>

func (m *AdjMxUi32) SetEdge(i, j VIdx, w int32) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                m.ws[uIdx(i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.ws[uIdx(j, i)] = w
        }</span>
}

// SetEdgeU is used iff i &gt;= j
func (m *AdjMxUi32) SetEdgeU(u, v VIdx, w int32) <span class="cov8" title="1">{
        m.ws[uIdx(u, v)] = w
}</span>

type AdjMxUf32 struct {
        adjMx
        ws []float32
}

func NewAdjMxUf32(order VIdx, reuse *AdjMxUf32) *AdjMxUf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUf32{
                        adjMx: adjMx{ord: order},
                        ws:    make([]float32, nSum(order)),
                }
        }</span> else<span class="cov8" title="1"> {
                reuse.ord = order
                reuse.ws = iutil.F32Slice(reuse.ws, int(nSum(order)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func AsAdjMxUf32(reuse *AdjMxUf32, weights []float32) (*AdjMxUf32, error) <span class="cov0" title="0">{
        sz, err := uOrdFromLen(len(weights))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if reuse == nil </span><span class="cov0" title="0">{
                reuse = new(AdjMxUf32)
        }</span>
        <span class="cov0" title="0">reuse.ord = sz
        reuse.ws = weights
        return reuse, nil</span>
}

func (m *AdjMxUf32) Init(w float32) *AdjMxUf32 <span class="cov8" title="1">{
        for i := range m.ws </span><span class="cov8" title="1">{
                m.ws[i] = w
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (m *AdjMxUf32) Reset(order VIdx) <span class="cov8" title="1">{
        NewAdjMxUf32(order, m)
        m.Init(NaN32())
}</span>

func (m *AdjMxUf32) Weight(i, j VIdx) interface{} <span class="cov8" title="1">{
        w := m.Edge(i, j)
        if math.IsNaN(float64(w)) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return w
        }</span>
}

func (m *AdjMxUf32) WeightU(i, j VIdx) interface{} <span class="cov8" title="1">{
        w := m.EdgeU(i, j)
        if math.IsNaN(float64(w)) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return w
        }</span>
}

func (m *AdjMxUf32) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, NaN32())
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(float32))
        }</span>
}

func (m *AdjMxUf32) SetWeightU(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdgeU(i, j, NaN32())
        }</span> else<span class="cov8" title="1"> {
                m.SetEdgeU(i, j, w.(float32))
        }</span>
}

func (m *AdjMxUf32) Edge(i, j VIdx) (w float32) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                return m.ws[uIdx(i, j)]
        }</span> else<span class="cov8" title="1"> {
                return m.ws[uIdx(j, i)]
        }</span>
}

// EdgeU is used iff i &gt;= j
func (m *AdjMxUf32) EdgeU(i, j VIdx) (w float32) <span class="cov8" title="1">{
        return m.ws[uIdx(i, j)]
}</span>

func (m *AdjMxUf32) SetEdge(i, j VIdx, w float32) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                m.ws[uIdx(i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.ws[uIdx(j, i)] = w
        }</span>
}

// SetEdgeU is used iff i &gt;= j
func (m *AdjMxUf32) SetEdgeU(i, j VIdx, w float32) <span class="cov8" title="1">{
        m.ws[uIdx(i, j)] = w
}</span>

// uIdx computes the index into the weight slice of an undirected matrix
func uIdx(i, j VIdx) VIdx <span class="cov8" title="1">{ return nSum(i) + j }</span>

func dOrdFromLen(sliceLen int) (order int, err error) <span class="cov8" title="1">{
        order = int(math.Sqrt(float64(sliceLen)))
        if order*order != sliceLen </span><span class="cov0" title="0">{
                return order, errors.New("weights slice is not square")
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}

func uOrdFromLen(sliceLen int) (order int, err error) <span class="cov8" title="1">{
        order = int(nSumRev(sliceLen))
        if nSum(order) != sliceLen </span><span class="cov0" title="0">{
                return order, errors.New("weights slice len is not sum(1,…,n)")
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package groph

type bitsWord = uint64

const (
        wordAll = 0xffff_ffff_ffff_ffff
        wordBits  = 64
        wordMask  = 0x3f
        wordShift = 6
)

type bitSet []bitsWord

func bitSetWords(setSize int) int <span class="cov8" title="1">{
        return (setSize + (wordBits - 1)) / wordBits
}</span>

func newBitSet(setSize int) bitSet <span class="cov0" title="0">{ return make(bitSet, bitSetWords(setSize))}</span>

func (bs bitSet) cap() int <span class="cov8" title="1">{ return len(bs) * wordBits }</span>

func (bs bitSet) get(i int) bool <span class="cov8" title="1">{
        w, b := i&gt;&gt;wordShift, i&amp;wordMask
        return bs[w]&amp;(1&lt;&lt;b) != 0
}</span>

func (bs bitSet) set(i int) <span class="cov8" title="1">{
        w, b := i&gt;&gt;wordShift, i&amp;wordMask
        bs[w] |= 1 &lt;&lt; b
}</span>

func (bs bitSet) unset(i int) <span class="cov8" title="1">{
        w, b := i&gt;&gt;wordShift, i&amp;wordMask
        bs[w] &amp;= ^(1 &lt;&lt; b)
}</span>

func (bs bitSet) clear() <span class="cov0" title="0">{
        for i := range bs </span><span class="cov0" title="0">{
                bs[i] = 0
        }</span>
}

func (bs bitSet) firstUnset() (res int) <span class="cov8" title="1">{
        var w bitsWord
        for res, w = range bs </span><span class="cov8" title="1">{
                if w != wordAll </span><span class="cov8" title="1">{
                        res *= wordBits                        
                        for b := bitsWord(1); w&amp;b == b; b &lt;&lt;= 1 </span><span class="cov8" title="1">{
                                res++
                        }</span>
                        <span class="cov8" title="1">return res</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package groph

import (
        "errors"
        "fmt"
)

// ClipError is returned when the order of src and dst in Cp*Weights does not
// match. If err is &lt; 0 there were -err vertices ignored from src. If err &gt; 0
// then err vertices in dst were not covered.
type ClipError int

func (err ClipError) Error() string <span class="cov0" title="0">{
        if err &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d vertices ignored from source", -err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d vertices not covered in destination", err)</span>
}

// Clipped returns the clipping if err is a ClipError. Otherwise it returns 0.
func Clipped(err error) int <span class="cov0" title="0">{
        if ce, ok := err.(ClipError); ok </span><span class="cov0" title="0">{
                return int(ce)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// SrcDstError is returned when an error occurred in the src or dst graph during
// Cp*Weights.
type SrcDstError struct {
        Src error
        Dst error
}

func (err SrcDstError) Error() string <span class="cov0" title="0">{
        if err.Src != nil </span><span class="cov0" title="0">{
                if err.Dst != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("source: %s; dest: %s", err.Src, err.Dst)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("source: %s", err.Src)</span>
        } else<span class="cov0" title="0"> if err.Dst != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("dest: %s", err.Dst)
        }</span>
        <span class="cov0" title="0">return "unspecific error"</span>
}

// MustCp panics when err is not nil. Otherwiese it returns g.
func MustCp(g WGraph, err error) WGraph <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

// CpWeights copies the edge weights from one graph to another.
// Vertices are identified by their index, i.e. the user has to take care of
// the vertex order. If the number of vertices in the graph differs the smaller
// graph determines how many edge weights are copied.
func CpWeights(dst WGraph, src RGraph) (dstout WGraph, err error) <span class="cov8" title="1">{
        sz := dst.Order()
        if src.Order() &lt; sz </span><span class="cov0" title="0">{
                sz = src.Order()
        }</span>
        <span class="cov8" title="1">if udst, ok := dst.(WUndirected); ok </span><span class="cov8" title="1">{
                if usrc, ok := src.(RUndirected); ok </span><span class="cov8" title="1">{
                        for i := V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                                udst.SetWeightU(i, i, usrc.WeightU(i, i))
                                for j := V0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                        udst.SetWeightU(i, j, usrc.WeightU(i, j))
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return dst, errors.New("cannot copy from directed to undirected graph")
                }</span>
        } else<span class="cov8" title="1"> if usrc, ok := src.(RUndirected); ok </span><span class="cov8" title="1">{
                for i := V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                        dst.SetWeight(i, i, usrc.WeightU(i, i))
                        for j := V0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                w := usrc.WeightU(i, j)
                                dst.SetWeight(i, j, w)
                                dst.SetWeight(j, i, w)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i := V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                        for j := V0; j &lt; sz; j++ </span><span class="cov8" title="1">{
                                dst.SetWeight(i, j, src.Weight(i, j))
                        }</span>
                }
        }
        <span class="cov8" title="1">sderr := SrcDstError{Src: errState(src), Dst: errState(dst)}
        if sderr.Src != nil || sderr.Dst != nil </span><span class="cov0" title="0">{
                return dst, sderr
        }</span>
        <span class="cov8" title="1">vnd := dst.Order() - src.Order()
        if vnd == 0 </span><span class="cov8" title="1">{
                return dst, nil
        }</span>
        <span class="cov0" title="0">return dst, ClipError(vnd)</span>
}

// CpXWeights “transfers” the edge weights from src Graph to dst Graph
// with the same vertex restrictions as CpWeights. CpXWeights applies
// the transformation function xf() to each edge weight.
//
// Panic of xf will be recovered and returned as error.
func CpXWeights(
        dst WGraph,
        src RGraph,
        xf func(in interface{}) interface{},
) (dstout WGraph, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        switch e := p.(type) </span>{
                        case error:<span class="cov0" title="0">
                                err = e</span>
                        default:<span class="cov0" title="0">
                                err = fmt.Errorf("panic: %v", p)</span>
                        }
                }
        }()
        <span class="cov8" title="1">sz := dst.Order()
        if src.Order() &lt; sz </span><span class="cov0" title="0">{
                sz = src.Order()
        }</span>
        <span class="cov8" title="1">var w interface{}
        if udst, ok := dst.(WUndirected); ok </span><span class="cov8" title="1">{
                if usrc, ok := src.(RUndirected); ok </span><span class="cov8" title="1">{
                        for i := V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                                w = usrc.WeightU(i, i)
                                udst.SetWeightU(i, i, xf(w))
                                for j := V0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                        w = usrc.WeightU(i, j)
                                        udst.SetWeightU(i, j, xf(w))
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return dst, errors.New("cannot copy from directed to undirected graph")
                }</span>
        } else<span class="cov8" title="1"> if usrc, ok := src.(RUndirected); ok </span><span class="cov8" title="1">{
                for i := V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                        w = usrc.WeightU(i, i)
                        dst.SetWeight(i, i, xf(w))
                        for j := V0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                w := xf(usrc.WeightU(i, j))
                                dst.SetWeight(i, j, w)
                                dst.SetWeight(j, i, w)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i := V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                        for j := V0; j &lt; sz; j++ </span><span class="cov8" title="1">{
                                w = src.Weight(i, j)
                                dst.SetWeight(i, j, xf(w))
                        }</span>
                }
        }
        <span class="cov8" title="1">vnd := dst.Order() - src.Order()
        if vnd == 0 </span><span class="cov8" title="1">{
                return dst, nil
        }</span>
        <span class="cov0" title="0">return dst, ClipError(vnd)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package groph

// VIdx is the type used to represent vertices in the graph implementations
// provided by the groph package.
type VIdx = int

const V0 VIdx = 0

// Edge represents a graphs edge between vertices U and V. For directed graphs
// its the edge from U to V.
type Edge struct {
        U, V VIdx
}

// RGraph represents graph that allows read only access to the egde
// weights.
//
// For graphs that can change be modified see WGraph. For undirected
// graphs see also RUndirected.
type RGraph interface {
        // Order return the numer of vertices in the graph.
        Order() VIdx
        // Returns the weight of the edge that connects the vertex with index
        // u with the vertex with index v. If there is no such edge it returns nil.
        Weight(u, v VIdx) interface{}
}

// RUndirected represents an undirected graph that allows read only
// access to the edge weights. For undirected graphs each edge (u,v) is
// considered outgiong as well as incoming for both, vertex u and vertext v.
type RUndirected interface {
        RGraph
        // Weight must only be called when u ≥ v.  Otherwise WeightU's
        // behaviour is unspecified, it even might crash.  In many
        // implementations this can be way more efficient than the
        // general case, see method Weight().
        WeightU(u, v VIdx) interface{}
}

// Directed returns true, iff g is a directed graph and false otherwise.
func Directed(g RGraph) bool <span class="cov8" title="1">{
        _, ok := g.(RUndirected)
        return !ok
}</span>

type VisitVertex = func(neighbour VIdx) (stop bool)

// OutLister is implemented by graph implementations that can easily iterate
// over all outgoing edges of one node.
//
// See also OutDegree and traverse.EachOutgoing function.
type OutLister interface {
        EachOutgoing(from VIdx, onDest VisitVertex) (stopped bool)
        OutDegree(v VIdx) int
}

// OutDegree returns the number of outgoing edges of vertex v in graph
// g. Note that for undirected graphs each edge is also considered to
// be an outgoing edge.
func OutDegree(g RGraph, v VIdx) (res int) <span class="cov0" title="0">{
        if ol, ok := g.(OutLister); ok </span><span class="cov0" title="0">{
                return ol.OutDegree(v)
        }</span>
        <span class="cov0" title="0">ord := g.Order()
        for i := V0; i &lt; ord; i++ </span><span class="cov0" title="0">{
                if g.Weight(v, i) != nil </span><span class="cov0" title="0">{
                        res++
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

// InLister is implemented by graph implementations that can easily iterate
// over all incoming edges of one node.
//
// See also InDegree and traverse.EachIncoming function.
type InLister interface {
        EachIncoming(to VIdx, onSource VisitVertex) (stopped bool)
        InDegree(v VIdx) int
}

// InDegree returns the number of incoming edges of vertex v in graph
// g. Note that for undirected graphs each edge is also considered to
// be an incoming edge.
func InDegree(g RGraph, v VIdx) (res int) <span class="cov0" title="0">{
        if il, ok := g.(InLister); ok </span><span class="cov0" title="0">{
                return il.InDegree(v)
        }</span>
        <span class="cov0" title="0">ord := g.Order()
        for i := V0; i &lt; ord; i++ </span><span class="cov0" title="0">{
                if g.Weight(i, v) != nil </span><span class="cov0" title="0">{
                        res++
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

type VisitEdge = func(u, v VIdx) (stop bool)

// InLister is implemented by graph implementations that can easily iterate
// over all edges of the graph.
//
// See also Size and traverse.EachEdge function.
type EdgeLister interface {
        EachEdge(onEdge VisitEdge) (stop bool)
        Size() int
}

// Size returns the number of edges in the graph g.
func Size(g RGraph) (res int) <span class="cov8" title="1">{
        switch xl := g.(type) </span>{
        case EdgeLister:<span class="cov0" title="0">
                return xl.Size()</span>
        case RUndirected:<span class="cov8" title="1">
                ord := g.Order()
                switch ls := g.(type) </span>{
                case OutLister:<span class="cov8" title="1">
                        for v := V0; v &lt; ord; v++ </span><span class="cov8" title="1">{
                                res += ls.OutDegree(v)
                        }</span>
                case InLister:<span class="cov0" title="0">
                        for v := V0; v &lt; ord; v++ </span><span class="cov0" title="0">{
                                res += ls.InDegree(v)
                        }</span>
                default:<span class="cov8" title="1">
                        for i := V0; i &lt; ord; i++ </span><span class="cov8" title="1">{
                                for j := V0; j &lt;= i; j++ </span><span class="cov8" title="1">{
                                        if xl.WeightU(i, j) != nil </span><span class="cov8" title="1">{
                                                res++
                                        }</span>
                                }
                        }
                }
        default:<span class="cov8" title="1">
                ord := g.Order()
                // TODO optimize with in/out lister
                for i := V0; i &lt; ord; i++ </span><span class="cov8" title="1">{
                        for j := V0; j &lt; ord; j++ </span><span class="cov8" title="1">{
                                if g.Weight(i, j) != nil </span><span class="cov8" title="1">{
                                        res++
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return res</span>
}

// WGraph represents graph that allows read and write access to the
// egde weights.
//
// For undirected graphs see also WUndirected.
type WGraph interface {
        RGraph
        // Reset resizes the graph to order and reinitializes it. Implementations
        // are expected to reuse memory.
        Reset(order VIdx)
        // SetWeight sets the edge weight for the edge starting at vertex u and
        // ending at vertex v. Passing w==nil removes the edge.
        SetWeight(u, v VIdx, w interface{})
}

// WUndirected represents an undirected graph that allows read and
// write access to the egde weights.
type WUndirected interface {
        WGraph
        // See RUndirected.WeightU
        WeightU(u, v VIdx) interface{}
        // SetWeightU must only be called when u ≥ v.  Otherwise
        // SetWeightU's behaviour is unspecified, it even might crash.
        //
        // See also RUndirected.WeightU
        SetWeightU(u, v VIdx, w interface{})
}

// Reset clears a WGraph while keeping the original order. This is the same as
// calling g.Reset(g.Order()).
func Reset(g WGraph) <span class="cov8" title="1">{ g.Reset(g.Order()) }</span>

// Set sets the weight of all passed edges to w.
func Set(g WGraph, w interface{}, edges ...Edge) <span class="cov8" title="1">{
        for _, e := range edges </span><span class="cov8" title="1">{
                g.SetWeight(e.U, e.V, w)
        }</span>
}

// RGbool represents a RGraph with boolean edge weights.
type RGbool interface {
        RGraph
        // Edge returns true, iff the edge (u,v) is in the graph.
        Edge(u, v VIdx) bool
}

// RUbool represents a RUndirected with boolean edge weights.
type RUbool interface {
        RGbool
        EdgeU(u, v VIdx) bool
}

// WGbool represents a WGraph with boolean edge weights.
type WGbool interface {
        WGraph
        // see RGbool
        Edge(u, v VIdx) bool
        // SetEdge removes the edge (u,v) from the graph when flag == bool.
        // Otherwise it adds the edge (u,v) to the graph.
        SetEdge(u, v VIdx, flag bool)
}

type WUbool interface {
        WGbool
        WeightU(u, v VIdx) interface{}
        SetWeightU(u, v VIdx, w interface{})
        EdgeU(u, v VIdx) bool
        SetEdgeU(u, v VIdx, flag bool)
}

// An RGi32 is a RGraph with type safe access to the edge weight of type
// int32. Besides type safety this avoids boxing/unboxing of the Weight
// method for performance reasons.
type RGi32 interface {
        RGraph
        // Edge returns ok == true, iff the edge (u,v) is in the graph. Then it will
        // also return the weight of the edge. Otherwise the value of weight is
        // unspecified.
        Edge(u, v VIdx) (weight int32, ok bool)
}

type RUi32 interface {
        RGi32
        EdgeU(u, v VIdx) (weight int32, ok bool)
}

// An WGi32 is to WGraph what RGi32 is to RGraph.
type WGi32 interface {
        WGraph
        // see RGi32
        Edge(u, v VIdx) (weight int32, ok bool)
        // SetEdge sets the weight of the edge (u,v). If the edge (u,v) was not in
        // the graph before, it is implicitly added.
        SetEdge(u, v VIdx, weight int32)
}

type WUi32 interface {
        WGi32
        WeightU(u, v VIdx) interface{}
        SetWeightU(u, v VIdx, w interface{})
        EdgeU(u, v VIdx) (weight int32, ok bool)
        SetEdgeU(u, v VIdx, weight int32)
}

// An RGf32 is a RGraph with type safe access to the edge weight of type
// float32. Besides type safety this avoids boxing/unboxing of the Weight
// method for performance reasons.
type RGf32 interface {
        RGraph
        // Edge returns Nan32() when the edge (u,v) is not in the graph. Otherwise
        // it returns the weight of the edge.
        Edge(u, v VIdx) (weight float32)
}

type RUf32 interface {
        RGf32
        EdgeU(u, v VIdx) (weight float32)
}

// An WGf32 is to WGraph what RGf32 is to RGraph.
type WGf32 interface {
        WGraph
        // see RGf32
        Edge(u, v VIdx) (weight float32)
        // SetEdge removes the edge (u,v) from the graph, iff weight is NaN32().
        // Othwerwise it sets the weight of the edge to weight.
        SetEdge(u, v VIdx, weight float32)
}

type WUf32 interface {
        WGf32
        WeightU(u, v VIdx) interface{}
        SetWeightU(u, v VIdx, w interface{})
        EdgeU(u, v VIdx) (weight float32)
        SetEdgeU(u, v VIdx, weight float32)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package test

import (
        "math"
        "math/rand"

        "git.fractalqb.de/fractalqb/groph"
)

type Point [2]float32

func Dist(p, q Point) float32 <span class="cov0" title="0">{
        d1 := p[0] - q[0]
        d2 := p[1] - q[1]
        return float32(math.Sqrt(float64(d1*d1 + d2*d2)))
}</span>

func RandomPoints(n groph.VIdx, ps []Point) []Point <span class="cov0" title="0">{
        if groph.VIdx(cap(ps)) &gt;= n </span><span class="cov0" title="0">{
                ps = ps[:n-1]
        }</span> else<span class="cov0" title="0"> {
                ps = make([]Point, n)
        }</span>
        <span class="cov0" title="0">for i := range ps </span><span class="cov0" title="0">{
                ps[i][0] = rand.Float32()
                ps[i][1] = rand.Float32()
        }</span>
        <span class="cov0" title="0">return ps</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package util

var VIdxSlice = IntSlice

func BoolSlice(s []bool, l int) []bool <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]bool, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func IntSlice(s []int, l int) []int <span class="cov8" title="1">{
        if s == nil || cap(s) &lt; l </span><span class="cov8" title="1">{
                return make([]int, l)
        }</span>
        <span class="cov8" title="1">return s[:l]</span>
}

func I32Slice(s []int32, l int) []int32 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]int32, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func U64Slice(s []uint64, l int) []uint64 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]uint64, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func F32Slice(s []float32, l int) []float32 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]float32, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package minspantree

import (
        "errors"
        "math"
        "sort"

        "git.fractalqb.de/fractalqb/groph"
)

func sortedEdges(g groph.RGf32) (res []groph.Edge) <span class="cov8" title="1">{
        vno := g.Order()
        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; vno; j++ </span><span class="cov8" title="1">{
                        if !math.IsNaN(float64(g.Edge(i, j))) </span><span class="cov8" title="1">{
                                res = append(res, groph.Edge{U: i, V: j})
                        }</span>
                }
        }
        <span class="cov8" title="1">sort.Slice(res, func(i, j int) bool </span><span class="cov8" title="1">{
                e1, e2 := &amp;res[i], &amp;res[j]
                return g.Edge(e1.U, e1.V) &lt; g.Edge(e2.U, e2.V)
        }</span>)
        <span class="cov8" title="1">return res</span>
}

// TODO more efficient way for bookkeping of connected sets?
func retag(f map[groph.VIdx]groph.VIdx, oldTag, newTag groph.VIdx) <span class="cov8" title="1">{
        for v, t := range f </span><span class="cov8" title="1">{
                if t == oldTag </span><span class="cov8" title="1">{
                        f[v] = newTag
                }</span>
        }
}

func Kruskalf32(g groph.RGf32, mst []groph.Edge) ([]groph.Edge, error) <span class="cov8" title="1">{
        if groph.Directed(g) </span><span class="cov0" title="0">{
                return mst, errors.New("cannot apply Kruskal's algorithm to directed graphs")
        }</span>
        <span class="cov8" title="1">mst = mst[:0]
        ebo := sortedEdges(g)
        frs := make(map[groph.VIdx]groph.VIdx)
        vc := groph.V0
        for _, e := range ebo </span><span class="cov8" title="1">{
                ti, iOk := frs[e.U]
                tj, jOk := frs[e.V]
                if iOk </span><span class="cov8" title="1">{
                        if jOk </span><span class="cov8" title="1">{ // no new vertex
                                if ti != tj </span><span class="cov8" title="1">{
                                        retag(frs, ti, tj)
                                        mst = append(mst, e)
                                }</span>
                        } else<span class="cov8" title="1"> { // j is new vertex
                                frs[e.V] = ti
                                mst = append(mst, e)
                                vc++
                                if vc == g.Order() </span><span class="cov8" title="1">{
                                        return mst, nil
                                }</span>
                        }
                } else<span class="cov8" title="1"> if jOk </span><span class="cov0" title="0">{ // i is new vertex
                        frs[e.U] = tj
                        mst = append(mst, e)
                        vc++
                        if vc == g.Order() </span><span class="cov0" title="0">{
                                return mst, nil
                        }</span>
                } else<span class="cov8" title="1"> { // i &amp; j are new vertices
                        frs[e.U] = e.U
                        frs[e.V] = e.U
                        mst = append(mst, e)
                        vc += 2
                        if vc == g.Order() </span><span class="cov0" title="0">{
                                return mst, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return mst, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package groph

import (
        "math"
)

// I32Del is used by default in adjacency matrices with edge weight
// type 'int32' to mark edges that do not exist.
//
// See AdjMxDi32 and AdjMxUi32
const I32Del = -2147483648 // min{ int32 }

var nan32 = float32(math.NaN())

// NaN32 is used by adjacency matrices with edge weight type 'float32'
// to mark edges that do not exist.
//
// See AdjMxDf32 and AdjMxUf32
func NaN32() float32 <span class="cov8" title="1">{ return nan32 }</span>

// IsNaN32 test is x is NaN (no a number). See also NaN32.
func IsNaN32(x float32) bool <span class="cov8" title="1">{ return math.IsNaN(float64(x)) }</span>

func errState(v interface{}) error <span class="cov8" title="1">{
        if es, ok := v.(interface{ ErrState() error }); ok </span><span class="cov0" title="0">{
                return es.ErrState()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// nSum computes the sum of the n 1st integers, i.e. 1+2+3+…+n
func nSum(n VIdx) VIdx <span class="cov8" title="1">{ return n * (n + 1) / 2 }</span>

func nSumRev(n VIdx) float64 <span class="cov8" title="1">{
        r := math.Sqrt(0.25 + 2*float64(n))
        return r - 0.5
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package groph

import "reflect"

// TODO can this be done in place?
func ReorderPath(slice interface{}, path []VIdx) <span class="cov8" title="1">{
        slv := reflect.ValueOf(slice)
        if slv.Len() == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tmp := make([]interface{}, slv.Len())
        for i := 0; i &lt; slv.Len(); i++ </span><span class="cov8" title="1">{
                tmp[i] = slv.Index(i).Interface()
        }</span>
        <span class="cov8" title="1">for w, r := range path </span><span class="cov8" title="1">{
                v := tmp[r]
                slv.Index(w).Set(reflect.ValueOf(v))
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package shortestpath

import (
        "container/heap"
        "math"

        "git.fractalqb.de/fractalqb/groph"
        iutil "git.fractalqb.de/fractalqb/groph/internal/util"
)

type pqItemi32 struct {
        v groph.VIdx
        p int32
}

type pqi32 struct {
        v2i []int
        is  []pqItemi32
}

func (pq *pqi32) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *pqi32) Less(i, j int) bool <span class="cov8" title="1">{
        pi, pj := pq.is[i].p, pq.is[j].p
        if pi &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if pj &lt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return pi &lt; pj</span>
}

func (pq *pqi32) Swap(i, j int) <span class="cov8" title="1">{
        ii, ij := pq.is[i], pq.is[j]
        pq.is[i], pq.is[j] = ij, ii
        pq.v2i[ii.v] = j
        pq.v2i[ij.v] = i
}</span>

func (pq *pqi32) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(pqItemi32)
        pq.v2i[item.v] = len(pq.is)
        pq.is = append(pq.is, item)
}</span>

func (pq *pqi32) Pop() interface{} <span class="cov8" title="1">{
        // TODO what about pq.v2i ?
        n := len(pq.is) - 1
        res := pq.is[n]
        pq.is = pq.is[:n]
        return res
}</span>

func (dij *pqi32) init(ord int) <span class="cov8" title="1">{
        dij.v2i = iutil.IntSlice(dij.v2i, ord)
        if dij.is == nil || cap(dij.is) &lt; ord </span><span class="cov8" title="1">{
                dij.is = make([]pqItemi32, 0, ord)
        }</span> else<span class="cov8" title="1"> {
                dij.is = dij.is[:0]
        }</span>
}

func (pq *pqi32) update(v groph.VIdx, priority int32) <span class="cov8" title="1">{
        i := pq.v2i[v]
        pq.is[i].p = priority
        heap.Fix(pq, i)
}</span>

type Dijkstrai32 struct {
        pq pqi32
}

func (dij *Dijkstrai32) init(ord int) <span class="cov8" title="1">{ dij.pq.init(ord) }</span>

func (dij *Dijkstrai32) On(
        g groph.RGi32,
        start groph.VIdx,
        dist []int32,
        prev []groph.VIdx,
) ([]int32, groph.Tree) <span class="cov8" title="1">{
        order := g.Order()
        dist = iutil.I32Slice(dist, order)
        if prev != nil </span><span class="cov8" title="1">{
                prev = iutil.VIdxSlice(prev, order)
        }</span>
        <span class="cov8" title="1">dij.init(order)
        dist[start] = 0
        for v := groph.V0; v &lt; g.Order(); v++ </span><span class="cov8" title="1">{
                if v != start </span><span class="cov8" title="1">{
                        dist[v] = -1
                }</span>
                <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                        prev[v] = -1
                }</span>
                <span class="cov8" title="1">heap.Push(&amp;dij.pq, pqItemi32{v, dist[v]})</span>
        }
        <span class="cov8" title="1">for dij.pq.Len() != 0 </span><span class="cov8" title="1">{
                u := heap.Pop(&amp;dij.pq).(pqItemi32).v
                groph.EachOutgoing(g, u, func(n groph.VIdx) (stop bool) </span><span class="cov8" title="1">{
                        alt := dist[u]
                        if alt &lt; 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">e, _ := g.Edge(u, n) // TODO EdgeD?
                        alt += e
                        if dist[n] &lt; 0 || alt &lt; dist[n] </span><span class="cov8" title="1">{
                                dist[n] = alt
                                if prev != nil </span><span class="cov8" title="1">{
                                        prev[n] = u
                                }</span>
                                <span class="cov8" title="1">dij.pq.update(n, alt)</span>
                        }
                        <span class="cov8" title="1">return false</span>
                })
        }
        <span class="cov8" title="1">return dist, prev</span>
}

type pqItemf32 struct {
        v groph.VIdx
        p float32
}

type pqf32 struct {
        v2i []int
        is  []pqItemf32
}

func (pq *pqf32) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *pqf32) Less(i, j int) bool <span class="cov8" title="1">{ return pq.is[i].p &lt; pq.is[j].p }</span>

func (pq *pqf32) Swap(i, j int) <span class="cov8" title="1">{
        ii, ij := pq.is[i], pq.is[j]
        pq.v2i[ii.v], pq.v2i[ij.v] = j, i
        pq.is[i], pq.is[j] = ij, ii
}</span>

func (pq *pqf32) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(pqItemf32)
        pq.v2i[item.v] = len(pq.is)
        pq.is = append(pq.is, item)
}</span>

func (pq *pqf32) Pop() interface{} <span class="cov8" title="1">{
        n := len(pq.is) - 1
        res := pq.is[n]
        pq.is = pq.is[:n]
        return res
}</span>

func (dij *pqf32) init(ord int) <span class="cov8" title="1">{
        dij.v2i = iutil.IntSlice(dij.v2i, ord)
        if dij.is == nil || cap(dij.is) &lt; ord </span><span class="cov8" title="1">{
                dij.is = make([]pqItemf32, 0, ord)
        }</span> else<span class="cov8" title="1"> {
                dij.is = dij.is[:0]
        }</span>
}

func (pq *pqf32) update(v groph.VIdx, priority float32) <span class="cov8" title="1">{
        i := pq.v2i[v]
        pq.is[i].p = priority
        heap.Fix(pq, i)
}</span>

type Dijkstraf32 struct {
        pq pqf32
}

func (dij *Dijkstraf32) init(ord int) <span class="cov8" title="1">{ dij.pq.init(ord) }</span>

func (dij *Dijkstraf32) On(
        g groph.RGf32,
        start groph.VIdx,
        dist []float32,
        prev []groph.VIdx,
) ([]float32, groph.Tree) <span class="cov8" title="1">{
        order := g.Order()
        dist = iutil.F32Slice(dist, order)
        if prev != nil </span><span class="cov8" title="1">{
                prev = iutil.VIdxSlice(prev, order)
        }</span>
        <span class="cov8" title="1">dij.init(order)
        dist[start] = 0
        for v := groph.V0; v &lt; g.Order(); v++ </span><span class="cov8" title="1">{
                if v != start </span><span class="cov8" title="1">{
                        dist[v] = float32(math.Inf(1))
                }</span>
                <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                        prev[v] = -1
                }</span>
                <span class="cov8" title="1">heap.Push(&amp;dij.pq, pqItemf32{v, dist[v]})</span>
        }
        <span class="cov8" title="1">for dij.pq.Len() != 0 </span><span class="cov8" title="1">{
                u := heap.Pop(&amp;dij.pq).(pqItemf32).v
                groph.EachOutgoing(g, u, func(n groph.VIdx) (stop bool) </span><span class="cov8" title="1">{
                        alt := dist[u] + g.Edge(u, n) // TODO EdgeU?
                        if alt &lt; dist[n] </span><span class="cov8" title="1">{
                                dist[n] = alt
                                if prev != nil </span><span class="cov8" title="1">{
                                        prev[n] = u
                                }</span>
                                <span class="cov8" title="1">dij.pq.update(n, alt)</span>
                        }
                        <span class="cov8" title="1">return false</span>
                })
        }
        <span class="cov8" title="1">return dist, prev</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package shortestpath

import "git.fractalqb.de/fractalqb/groph"

func FloydWarshallf32(g groph.WGf32) <span class="cov8" title="1">{
        vno := g.Order()
        if u, ok := g.(groph.WUf32); ok </span><span class="cov8" title="1">{
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                        ds := u.Edge(i, k) + u.Edge(k, j)
                                        if u.EdgeU(i, j) &gt; ds </span><span class="cov8" title="1">{
                                                u.SetEdgeU(i, j, ds)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds := g.Edge(i, k) + g.Edge(k, j)
                                        if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        }
}

func FloydWarshalli32(g groph.WGi32) <span class="cov8" title="1">{
        vno := g.Order()
        if u, ok := g.(groph.WUi32); ok </span><span class="cov0" title="0">{
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov0" title="0">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov0" title="0">{
                                for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                        ds, ok := u.Edge(i, k)
                                        if !ok </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if tmp, ok := u.Edge(k, j); ok </span><span class="cov0" title="0">{
                                                ds += tmp
                                        }</span> else<span class="cov0" title="0"> {
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if d, ok := u.EdgeU(i, j); !ok || d &gt; ds </span><span class="cov0" title="0">{
                                                u.SetEdgeU(i, j, ds)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds, ok := g.Edge(i, k)
                                        if !ok </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tmp, ok := g.Edge(k, j); ok </span><span class="cov8" title="1">{
                                                ds += tmp
                                        }</span> else<span class="cov8" title="1"> {
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        }
}

func FloydWarshallAdjMxDf32(g *groph.AdjMxDf32) <span class="cov8" title="1">{
        vno := g.Order()
        for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                ds := g.Edge(i, k) + g.Edge(k, j)
                                if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                        g.SetEdge(i, j, ds)
                                }</span>
                        }
                }
        }
}

func FloydWarshallAdjMxDi32(g *groph.AdjMxDi32) <span class="cov8" title="1">{
        vno := g.Order()
        for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                ds, ok := g.Edge(i, k)
                                if !ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if tmp, ok := g.Edge(k, j); ok </span><span class="cov8" title="1">{
                                        ds += tmp
                                }</span> else<span class="cov8" title="1"> {
                                        continue</span>
                                }
                                <span class="cov8" title="1">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov8" title="1">{
                                        g.SetEdge(i, j, ds)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package groph

type spmro map[VIdx]interface{}

type SoMD struct {
        ws []spmro
}

func NewSoMD(order VIdx, reuse *SoMD) *SoMD <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SoMD{make([]spmro, order)}
        }</span>
        <span class="cov8" title="1">reuse.Reset(order)
        return reuse</span>
}

func (g *SoMD) Order() VIdx <span class="cov8" title="1">{ return len(g.ws) }</span>

func (g *SoMD) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        row := g.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return row[v]</span>
}

func (g *SoMD) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        row := g.ws[u]
        if w == nil </span><span class="cov8" title="1">{
                delete(row, v)
        }</span> else<span class="cov8" title="1"> {
                if row == nil </span><span class="cov8" title="1">{
                        row = make(spmro)
                        g.ws[u] = row
                }</span>
                <span class="cov8" title="1">row[v] = w</span>
        }
}

func (g *SoMD) Reset(order VIdx) <span class="cov8" title="1">{
        if g.ws == nil || cap(g.ws) &lt; order </span><span class="cov8" title="1">{
                g.ws = make([]spmro, order)
        }</span> else<span class="cov8" title="1"> {
                g.ws = g.ws[:order]
                for i := range g.ws </span><span class="cov8" title="1">{
                        g.ws[i] = nil
                }</span>
        }
}

func (g *SoMD) EachOutgoing(from VIdx, onDest VisitVertex) (stopped bool) <span class="cov0" title="0">{
        if row := g.ws[from]; row != nil </span><span class="cov0" title="0">{
                for n := range row </span><span class="cov0" title="0">{
                        if onDest(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (g *SoMD) OutDegree(v VIdx) int <span class="cov0" title="0">{
        row := g.ws[v]
        if row == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(row)</span>
}

type SoMU struct {
        SoMD
}

func NewSoMU(order VIdx, reuse *SoMU) *SoMU <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = new(SoMU)
        }</span>
        <span class="cov8" title="1">NewSoMD(order, &amp;reuse.SoMD)
        return reuse</span>
}

func (g *SoMU) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{
        return g.SoMD.Weight(u, v)
}</span>

func (g *SoMU) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return g.WeightU(u, v)
        }</span>
        <span class="cov8" title="1">return g.WeightU(v, u)</span>
}

func (g *SoMU) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        g.SoMD.SetWeight(u, v, w)
}</span>

func (g *SoMU) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                g.SetWeightU(u, v, w)
        }</span> else<span class="cov8" title="1"> {
                g.SetWeightU(v, u, w)
        }</span>
}

type spmroi32 map[VIdx]int32

type SoMDi32 struct {
        ws  []spmroi32
        Del int32
}

func NewSoMDi32(order VIdx, reuse *SoMDi32) *SoMDi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SoMDi32{
                        ws:  make([]spmroi32, order),
                        Del: I32Del,
                }
        }</span>
        <span class="cov8" title="1">reuse.Reset(order)
        return reuse</span>
}

func (g *SoMDi32) Order() VIdx <span class="cov8" title="1">{ return len(g.ws) }</span>

func (m *SoMDi32) Edge(u, v VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        row := m.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if res, ok := row[v]; ok </span><span class="cov8" title="1">{
                return res, true
        }</span>
        <span class="cov8" title="1">return 0, false</span>
}

func (g *SoMDi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if res, ok := g.Edge(u, v); ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (g *SoMDi32) SetEdge(u, v VIdx, w int32) <span class="cov8" title="1">{
        row := g.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                row = make(spmroi32)
                g.ws[u] = row
        }</span>
        <span class="cov8" title="1">row[v] = w</span>
}

func (g *SoMDi32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                delete(g.ws[u], v)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdge(u, v, w.(int32))
        }</span>
}

func (g *SoMDi32) Reset(order VIdx) <span class="cov8" title="1">{
        if g.ws == nil || cap(g.ws) &lt; order </span><span class="cov8" title="1">{
                g.ws = make([]spmroi32, order)
        }</span> else<span class="cov8" title="1"> {
                g.ws = g.ws[:order]
                for i := range g.ws </span><span class="cov8" title="1">{
                        g.ws[i] = nil
                }</span>
        }
}

func (g *SoMDi32) EachOutgoing(from VIdx, onDest VisitVertex) (stopped bool) <span class="cov0" title="0">{
        if row := g.ws[from]; row != nil </span><span class="cov0" title="0">{
                for n := range row </span><span class="cov0" title="0">{
                        if onDest(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (g *SoMDi32) OutDegree(v VIdx) int <span class="cov8" title="1">{
        row := g.ws[v]
        if row == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(row)</span>
}

type SoMUi32 struct {
        SoMDi32
}

func NewSoMUi32(order VIdx, reuse *SoMUi32) *SoMUi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = new(SoMUi32)
        }</span>
        <span class="cov8" title="1">NewSoMDi32(order, &amp;reuse.SoMDi32)
        return reuse</span>
}

func (g *SoMUi32) EdgeU(u, v VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        return g.SoMDi32.Edge(u, v)
}</span>

func (g *SoMUi32) Edge(u, v VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return g.EdgeU(u, v)
        }</span>
        <span class="cov8" title="1">return g.EdgeU(v, u)</span>
}

func (g *SoMUi32) SetEdgeU(u, v VIdx, w int32) <span class="cov8" title="1">{
        g.SoMDi32.SetEdge(u, v, w)
}</span>

func (g *SoMUi32) SetEdge(u, v VIdx, w int32) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                g.SetEdgeU(u, v, w)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdgeU(v, u, w)
        }</span>
}

func (g *SoMUi32) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{
        return g.SoMDi32.Weight(u, v)
}</span>

func (g *SoMUi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return g.WeightU(u, v)
        }</span>
        <span class="cov8" title="1">return g.WeightU(v, u)</span>
}

func (g *SoMUi32) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        g.SoMDi32.SetWeight(u, v, w)
}</span>

func (g *SoMUi32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                g.SetWeightU(u, v, w)
        }</span> else<span class="cov8" title="1"> {
                g.SetWeightU(v, u, w)
        }</span>
}

type spmrof32 map[VIdx]float32

type SoMDf32 struct {
        ws []spmrof32
}

func NewSoMDf32(order VIdx, reuse *SoMDf32) *SoMDf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SoMDf32{make([]spmrof32, order)}
        }</span>
        <span class="cov8" title="1">reuse.Reset(order)
        return reuse</span>
}

func (g *SoMDf32) Order() VIdx <span class="cov8" title="1">{ return len(g.ws) }</span>

func (m *SoMDf32) Edge(u, v VIdx) (w float32) <span class="cov8" title="1">{
        row := m.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                return NaN32()
        }</span>
        <span class="cov8" title="1">if res, ok := row[v]; ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return NaN32()</span>
}

func (g *SoMDf32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if res := g.Edge(u, v); IsNaN32(res) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return res
        }</span>
}

func (g *SoMDf32) SetEdge(u, v VIdx, w float32) <span class="cov8" title="1">{
        row := g.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                row = make(spmrof32)
                g.ws[u] = row
        }</span>
        <span class="cov8" title="1">row[v] = w</span>
}

func (g *SoMDf32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                delete(g.ws[u], v)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdge(u, v, w.(float32))
        }</span>
}

func (g *SoMDf32) Reset(order VIdx) <span class="cov8" title="1">{
        if g.ws == nil || cap(g.ws) &lt; order </span><span class="cov8" title="1">{
                g.ws = make([]spmrof32, order)
        }</span> else<span class="cov8" title="1"> {
                g.ws = g.ws[:order]
                for i := range g.ws </span><span class="cov8" title="1">{
                        g.ws[i] = nil
                }</span>
        }
}

func (g *SoMDf32) EachOutgoing(from VIdx, onDest VisitVertex) (stopped bool) <span class="cov0" title="0">{
        if row := g.ws[from]; row != nil </span><span class="cov0" title="0">{
                for n := range row </span><span class="cov0" title="0">{
                        if onDest(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (g *SoMDf32) OutDegree(v VIdx) int <span class="cov0" title="0">{
        row := g.ws[v]
        if row == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(row)</span>
}

type SoMUf32 struct {
        SoMDf32
}

func NewSoMUf32(order VIdx, reuse *SoMUf32) *SoMUf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = new(SoMUf32)
        }</span>
        <span class="cov8" title="1">NewSoMDf32(order, &amp;reuse.SoMDf32)
        return reuse</span>
}

func (g *SoMUf32) EdgeU(u, v VIdx) float32 <span class="cov8" title="1">{
        return g.SoMDf32.Edge(u, v)
}</span>

func (g *SoMUf32) Edge(u, v VIdx) float32 <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return g.EdgeU(u, v)
        }</span>
        <span class="cov8" title="1">return g.EdgeU(v, u)</span>
}

func (g *SoMUf32) SetEdgeU(u, v VIdx, w float32) <span class="cov8" title="1">{
        g.SoMDf32.SetEdge(u, v, w)
}</span>

func (g *SoMUf32) SetEdge(u, v VIdx, w float32) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                g.SetEdgeU(u, v, w)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdgeU(v, u, w)
        }</span>
}

func (g *SoMUf32) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{
        return g.SoMDf32.Weight(u, v)
}</span>

func (g *SoMUf32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return g.WeightU(u, v)
        }</span>
        <span class="cov8" title="1">return g.WeightU(v, u)</span>
}

func (g *SoMUf32) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        g.SoMDf32.SetWeight(u, v, w)
}</span>

func (g *SoMUf32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                g.SetWeightU(u, v, w)
        }</span> else<span class="cov8" title="1"> {
                g.SetWeightU(v, u, w)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package traverse

import (
        "container/heap"
        "sort"

        "git.fractalqb.de/fractalqb/groph"
        iutil "git.fractalqb.de/fractalqb/groph/internal/util"
)

type VisitVertex = func(pred, v groph.VIdx, circle bool) (stop bool)

type VisitInCluster = func(pred, v groph.VIdx, circle bool, cluster int) (stop bool)

// Search performs depth-first or breadth-breadth searches of
// groph.RGraph objects.
type Search struct {
        g     groph.RGraph
        mem   []groph.Edge
        tail  int
        visit hitPq
        // If not nil SortBy is used to sort the neighbours v of node u. SortBy
        // returns true if the edge (u,v1) is less than (u,v2).
        SortBy func(u, v1, v2 groph.VIdx) bool
}

func NewSearch(g groph.RGraph) *Search <span class="cov8" title="1">{
        res := &amp;Search{g: g}
        res.visit.reset(g.Order())
        return res
}</span>

func (df *Search) Reset(g groph.RGraph) <span class="cov8" title="1">{
        df.g = g
        df.visit.reset(g.Order())
}</span>

type stepFn = func(g groph.RGraph, v groph.VIdx, on groph.VisitVertex) bool

// Depth1stAt performs a depth-first search on the respective
// RGraph. The search starts at vertex start and terminates when no
// further vertices can be reached via an edge of the graph. It
// returns the number of distinct vertex hits during the search and
// an indicator if the visit function 'do' stopped the search.
func (df *Search) AdjDepth1stAt(start groph.VIdx, do VisitVertex) (hits int, stopped bool) <span class="cov8" title="1">{
        return df.d1stAt(start, do, groph.EachAdjacent)
}</span>

func (df *Search) OutDepth1stAt(start groph.VIdx, do VisitVertex) (hits int, stopped bool) <span class="cov0" title="0">{
        return df.d1stAt(start, do, groph.EachOutgoing)
}</span>

func (df *Search) InDepth1stAt(start groph.VIdx, do VisitVertex) (hits int, stopped bool) <span class="cov0" title="0">{
        return df.d1stAt(start, do, groph.EachIncoming)
}</span>

func (df *Search) d1stAt(
        start groph.VIdx,
        do VisitVertex,
        eachNext stepFn,
) (hits int, stopped bool) <span class="cov8" title="1">{
        if h := df.visit.hits(start); h &gt; 0 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if df.mem != nil </span><span class="cov8" title="1">{
                df.mem = df.mem[:0]
        }</span>
        <span class="cov8" title="1">step := groph.Edge{U: -1, V: start}
        df.push(step)
        df.visit.setHits(start, 1)
        var onDest func(d groph.VIdx) (stop bool)
        if groph.Directed(df.g) </span><span class="cov8" title="1">{
                onDest = func(d groph.VIdx) bool </span><span class="cov8" title="1">{ return df.checkDDest(step, d, do) }</span>
        } else<span class="cov8" title="1"> {
                onDest = func(d groph.VIdx) bool </span><span class="cov8" title="1">{ return df.checkUDest(step, d, do) }</span>
        }
        <span class="cov8" title="1">for len(df.mem) &gt; 0 </span><span class="cov8" title="1">{
                step = df.pop()
                if do(step.U, step.V, false) </span><span class="cov0" title="0">{
                        return hits + 1, true
                }</span>
                <span class="cov8" title="1">hits++
                sortStart := len(df.mem)
                if eachNext(df.g, step.V, onDest) </span><span class="cov0" title="0">{
                        return hits, true
                }</span>
                <span class="cov8" title="1">if df.SortBy != nil </span><span class="cov8" title="1">{
                        sort.Slice(df.mem[sortStart:], func(v1, v2 int) bool </span><span class="cov8" title="1">{
                                return !df.SortBy(step.V, v1, v2)
                        }</span>)
                }
        }
        <span class="cov8" title="1">return hits, false</span>
}

func (df *Search) AdjDepth1st(stopToNextCluster bool, do VisitInCluster) (stopped bool) <span class="cov8" title="1">{
        return df.d1st(stopToNextCluster, do, groph.EachAdjacent)
}</span>

func (df *Search) OutDepth1st(stopToNextCluster bool, do VisitInCluster) (stopped bool) <span class="cov0" title="0">{
        return df.d1st(stopToNextCluster, do, groph.EachOutgoing)
}</span>

func (df *Search) InDepth1st(stopToNextCluster bool, do VisitInCluster) (stopped bool) <span class="cov0" title="0">{
        return df.d1st(stopToNextCluster, do, groph.EachIncoming)
}</span>

func (df *Search) d1st(
        stopToNextCluster bool,
        do VisitInCluster,
        eachNext stepFn,
) (stopped bool) <span class="cov8" title="1">{
        cluster := 0
        cdo := func(p, n groph.VIdx, c bool) bool </span><span class="cov8" title="1">{ return do(p, n, c, cluster) }</span>
        <span class="cov8" title="1">hits, stop := df.d1stAt(0, cdo, eachNext)
        if stop </span><span class="cov0" title="0">{
                if !stopToNextCluster </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">cluster = -1</span>
        }
        <span class="cov8" title="1">for hits &lt; df.g.Order() </span><span class="cov0" title="0">{
                if cluster &gt;= 0 </span><span class="cov0" title="0">{
                        cluster++
                }</span>
                <span class="cov0" title="0">start := df.visit.top() // TODO assert hits(start) == 0
                n, stop := df.d1stAt(start, cdo, eachNext)
                if stop </span><span class="cov0" title="0">{
                        if !stopToNextCluster </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">cluster = -1</span>
                }
                <span class="cov0" title="0">hits += n</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Breadth1stAt performs a breadth-first search on the respective
// RGraph. The search starts at vertex start and terminates when no
// further vertices can be reached via an edge of the graph. It
// returns the number of distinct vertex hits during the search and an
// indicator if the visit function 'do' stopped the search.

func (df *Search) AdjBreadth1stAt(start groph.VIdx, do VisitVertex) (hits int, stopped bool) <span class="cov8" title="1">{
        return df.b1stAt(start, do, groph.EachAdjacent)
}</span>

func (df *Search) OutBreadth1stAt(start groph.VIdx, do VisitVertex) (hits int, stopped bool) <span class="cov0" title="0">{
        return df.b1stAt(start, do, groph.EachOutgoing)
}</span>

func (df *Search) InBreadth1stAt(start groph.VIdx, do VisitVertex) (hits int, stopped bool) <span class="cov0" title="0">{
        return df.b1stAt(start, do, groph.EachIncoming)
}</span>

func (df *Search) b1stAt(
        start groph.VIdx,
        do VisitVertex,
        eachNext stepFn,
) (hits int, stopped bool) <span class="cov8" title="1">{
        if h := df.visit.hits(start); h &gt; 0 </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if df.mem != nil </span><span class="cov8" title="1">{
                df.mem = df.mem[:0]
        }</span>
        <span class="cov8" title="1">df.tail = 0
        step := groph.Edge{U: -1, V: start}
        df.push(step)
        df.visit.setHits(start, 1)
        var onDest func(d groph.VIdx) (stop bool)
        if groph.Directed(df.g) </span><span class="cov8" title="1">{
                onDest = func(d groph.VIdx) bool </span><span class="cov8" title="1">{ return df.checkDDest(step, d, do) }</span>
        } else<span class="cov8" title="1"> {
                onDest = func(d groph.VIdx) bool </span><span class="cov8" title="1">{ return df.checkUDest(step, d, do) }</span>
        }
        <span class="cov8" title="1">for df.tail &lt; len(df.mem) </span><span class="cov8" title="1">{
                step = df.take()
                if do(step.U, step.V, false) </span><span class="cov0" title="0">{
                        return hits + 1, true
                }</span>
                <span class="cov8" title="1">hits++
                sortStart := len(df.mem)
                if eachNext(df.g, step.V, onDest) </span><span class="cov0" title="0">{
                        return hits, true
                }</span>
                <span class="cov8" title="1">if df.SortBy != nil </span><span class="cov0" title="0">{
                        sort.Slice(df.mem[sortStart:], func(v1, v2 int) bool </span><span class="cov0" title="0">{
                                return df.SortBy(step.V, v1, v2)
                        }</span>)
                }
        }
        <span class="cov8" title="1">return hits, false</span>
}

func (df *Search) AdjBreadth1st(stopToNextCluster bool, do VisitInCluster) (stopped bool) <span class="cov8" title="1">{
        return df.b1st(stopToNextCluster, do, groph.EachAdjacent)
}</span>

func (df *Search) OutBreadth1st(stopToNextCluster bool, do VisitInCluster) (stopped bool) <span class="cov0" title="0">{
        return df.b1st(stopToNextCluster, do, groph.EachOutgoing)
}</span>

func (df *Search) InBreadth1st(stopToNextCluster bool, do VisitInCluster) (stopped bool) <span class="cov0" title="0">{
        return df.b1st(stopToNextCluster, do, groph.EachIncoming)
}</span>

func (df *Search) b1st(
        stopToNextCluster bool,
        do VisitInCluster,
        eachNext stepFn,
) (stopped bool) <span class="cov8" title="1">{
        cluster := 0
        cdo := func(p, n groph.VIdx, c bool) bool </span><span class="cov8" title="1">{ return do(p, n, c, cluster) }</span>
        <span class="cov8" title="1">hits, stop := df.b1stAt(0, cdo, eachNext)
        if stop </span><span class="cov0" title="0">{
                if !stopToNextCluster </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">cluster = -1</span>
        }
        <span class="cov8" title="1">for hits &lt; df.g.Order() </span><span class="cov0" title="0">{
                if cluster &gt;= 0 </span><span class="cov0" title="0">{
                        cluster++
                }</span>
                <span class="cov0" title="0">start := df.visit.top() // TODO assert hits(start) == 0
                n, stop := df.b1stAt(start, cdo, eachNext)
                if stop </span><span class="cov0" title="0">{
                        if !stopToNextCluster </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">cluster = -1</span>
                }
                <span class="cov0" title="0">hits += n</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (df *Search) Hits(v groph.VIdx) int <span class="cov8" title="1">{
        if v &gt;= len(df.visit.v2i) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">ii := df.visit.v2i[v]
        if ii &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return df.visit.is[ii].hits</span>
}

func (df *Search) LeastHits() (v groph.VIdx, hits int) <span class="cov0" title="0">{
        if len(df.visit.is) == 0 </span><span class="cov0" title="0">{
                return -1, -1
        }</span>
        <span class="cov0" title="0">item := df.visit.is[0]
        return item.v, item.hits</span>
}

func (df *Search) checkDDest(pre groph.Edge, d groph.VIdx, do VisitVertex) bool <span class="cov8" title="1">{
        h := df.visit.hits(d)
        if h == 0 </span><span class="cov8" title="1">{
                df.push(groph.Edge{U: pre.V, V: d})
        }</span> else<span class="cov8" title="1"> {
                return do(pre.V, d, true)
        }</span>
        <span class="cov8" title="1">df.visit.setHits(d, h+1)
        return false</span>
}

func (df *Search) checkUDest(pre groph.Edge, d groph.VIdx, do VisitVertex) bool <span class="cov8" title="1">{
        if d == pre.U || d == pre.V </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return df.checkDDest(pre, d, do)</span>
}

func (df *Search) push(e groph.Edge) <span class="cov8" title="1">{
        df.mem = append(df.mem, e)
}</span>

func (df *Search) pop() (step groph.Edge) <span class="cov8" title="1">{
        l := len(df.mem) - 1
        step = df.mem[l]
        df.mem = df.mem[:l]
        return step
}</span>

func (df *Search) take() (step groph.Edge) <span class="cov8" title="1">{
        step = df.mem[df.tail]
        df.tail++
        return step
}</span>

type hitPqItem struct {
        hits int
        v    groph.VIdx
}

type hitPq struct {
        v2i []int
        is  []hitPqItem
}

func (pq *hitPq) reset(ord groph.VIdx) <span class="cov8" title="1">{
        pq.v2i = iutil.IntSlice(pq.v2i, ord)
        if pq.is == nil || cap(pq.is) &lt; ord </span><span class="cov8" title="1">{
                pq.is = make([]hitPqItem, ord)
        }</span> else<span class="cov8" title="1"> {
                pq.is = pq.is[:ord]
        }</span>
        <span class="cov8" title="1">for i := range pq.is </span><span class="cov8" title="1">{
                pq.v2i[i] = i
                pq.is[i] = hitPqItem{hits: 0, v: i}
        }</span>
}

func (pq *hitPq) top() groph.VIdx <span class="cov0" title="0">{ return pq.is[0].v }</span>

func (pq *hitPq) hits(v groph.VIdx) int <span class="cov8" title="1">{ return pq.is[pq.v2i[v]].hits }</span>

func (pq *hitPq) setHits(v groph.VIdx, hits int) <span class="cov8" title="1">{
        ii := pq.v2i[v]
        pq.is[ii].hits = hits
        heap.Fix(pq, ii)
}</span>

func (pq *hitPq) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *hitPq) Less(i, j int) bool <span class="cov8" title="1">{ return pq.is[i].hits &lt; pq.is[j].hits }</span>

func (pq *hitPq) Swap(i, j int) <span class="cov8" title="1">{
        ii, ji := pq.is[i], pq.is[j]
        pq.is[i], pq.is[j] = ji, ii
        pq.v2i[ii.v] = j
        pq.v2i[ji.v] = i
}</span>

func (pq *hitPq) Push(x interface{}) <span class="cov0" title="0">{
        panic("must not be called")</span>
        // pqItem := x.(hitPqItem)
        // for pqItem.v &gt;= len(pq.v2i) {
        //         pq.v2i = append(pq.v2i, -1)
        // }
        // pq.v2i[pqItem.v] = len(pq.is)
        // pq.is = append(pq.is, pqItem)
}

func (pq *hitPq) Pop() interface{} <span class="cov0" title="0">{
        panic("must not be called")</span>
        // lm1 := len(pq.is) - 1
        // res := pq.is[lm1]
        // pq.is = pq.is[:lm1]
        // pq.v2i[res.v] = -1
        // return res
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package groph

type Tree []VIdx

func (t Tree) Root() (res VIdx) <span class="cov0" title="0">{
        max := len(t)
        for n := t[res]; n &gt;= 0; n = t[res] </span><span class="cov0" title="0">{
                res = n
                if max--; max == 0 </span><span class="cov0" title="0">{
                        return -1
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (t Tree) Order() VIdx <span class="cov0" title="0">{ return len(t) }</span>

func (t Tree) EdgeU(u, v VIdx) bool <span class="cov0" title="0">{
        return t[u] == v || t[v] == u
}</span>

func (t Tree) Edge(u, v VIdx) bool <span class="cov0" title="0">{
        if u &gt; v </span><span class="cov0" title="0">{
                return t.EdgeU(u, v)
        }</span>
        <span class="cov0" title="0">return t.EdgeU(v, u)</span>
}

func (t Tree) WeightU(u, v VIdx) interface{} <span class="cov0" title="0">{
        if t.EdgeU(u, v) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t Tree) Weight(u, v VIdx) interface{} <span class="cov0" title="0">{
        if t.Edge(u, v) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t Tree) EachOutgoing(from VIdx, onDest VisitVertex) (stop bool) <span class="cov0" title="0">{
        if dest := t[from]; dest &gt;= 0 </span><span class="cov0" title="0">{
                if onDest(dest) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (t Tree) OutDegree(v VIdx) int <span class="cov0" title="0">{
        if t[v] &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return 1</span>
}

func (t Tree) EachEdge(onEdge VisitEdge) (stop bool) <span class="cov0" title="0">{
        for u, v := range t </span><span class="cov0" title="0">{
                if v &gt;= 0 </span><span class="cov0" title="0">{
                        if onEdge(u, v) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (t Tree) Size() int <span class="cov0" title="0">{ return len(t) - 1 }</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package tsp

import "git.fractalqb.de/fractalqb/groph"

// d2optU computes the difference in weight sum for a specific 2-opt operation
// that swaps e0 / e1 for undirected graphs.
func diff2optU(g groph.RGf32, p []groph.VIdx, e0, e1 groph.VIdx) (wdiff float32) <span class="cov8" title="1">{
        lenp := groph.VIdx(len(p))
        wdiff = -g.Edge(p[e0], p[e0+1])
        wdiff += g.Edge(p[e0], p[e1])
        if e1+1 == lenp </span><span class="cov8" title="1">{
                wdiff -= g.Edge(p[e1], p[0])
                wdiff += g.Edge(p[e0+1], p[0])
        }</span> else<span class="cov8" title="1"> {
                wdiff -= g.Edge(p[e1], p[e1+1])
                wdiff += g.Edge(p[e0+1], p[e1+1])
        }</span>
        <span class="cov8" title="1">return wdiff</span>
}

// d2optD computes the difference in weight sum for a specific 2-opt operation
// that swaps e0 / e1 for directed graphs.
func diff2optD(g groph.RGf32, p []groph.VIdx, e0, e1 groph.VIdx) (wdiff float32) <span class="cov8" title="1">{
        wdiff = diff2optU(g, p, e0, e1)
        for i := e0 + 1; i &lt; e1; i++ </span><span class="cov8" title="1">{
                wdiff -= g.Edge(p[i], p[i+1])
                wdiff += g.Edge(p[i+1], p[i])
        }</span>
        <span class="cov8" title="1">return wdiff</span>
}

func apply2opt(p []groph.VIdx, e0, e1 groph.VIdx) <span class="cov8" title="1">{
        e0++
        for e0 &lt; e1 </span><span class="cov8" title="1">{
                p[e0], p[e1] = p[e1], p[e0]
                e0++
                e1--
        }</span>
}

func TwoOptf32(g groph.RGf32) (path []groph.VIdx, plen float32) <span class="cov8" title="1">{
        var diff2opt func(groph.RGf32, []groph.VIdx, groph.VIdx, groph.VIdx) float32
        if groph.Directed(g) </span><span class="cov8" title="1">{
                diff2opt = diff2optD
        }</span> else<span class="cov8" title="1"> {
                diff2opt = diff2optU
        }</span>
        <span class="cov8" title="1">vno := g.Order()
        path = make([]groph.VIdx, vno)
        for i := groph.V0; i+1 &lt; vno; i++ </span><span class="cov8" title="1">{
                path[i] = i
                plen += g.Edge(i, i+1)
        }</span>
        <span class="cov8" title="1">path[vno-1] = vno - 1
        plen += g.Edge(vno-1, 0)
        for </span><span class="cov8" title="1">{
                be0, be1 := vno, vno
                bdiff := float32(0)
                for e0 := groph.V0; e0 &lt; vno; e0++ </span><span class="cov8" title="1">{
                        for e1 := e0 + 1; e1 &lt; vno; e1++ </span><span class="cov8" title="1">{
                                diff := diff2opt(g, path, e0, e1)
                                if diff &lt; bdiff </span><span class="cov8" title="1">{
                                        be0, be1 = e0, e1
                                        bdiff = diff
                                }</span>
                        }
                }
                <span class="cov8" title="1">if bdiff &lt; float32(0) </span><span class="cov8" title="1">{
                        apply2opt(path, be0, be1)
                        plen += bdiff
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
        <span class="cov8" title="1">return path, plen</span>
}

// Benchmark showed that the proformance gain is not worth it
// func (g *AdjMxDf32) Tsp2Opt() (path []uint, plen float32) {
//         vno := g.Order()
//         path = make([]uint, vno)
//         for i := uint(0); i+1 &lt; vno; i++ {
//                 path[i] = i
//                 plen += g.Edge(i, i+1)
//         }
//         path[vno-1] = vno - 1
//         plen += g.Edge(vno-1, 0)
//         for {
//                 be0, be1 := vno, vno
//                 bdiff := float32(0)
//                 for e0 := uint(0); e0 &lt; vno; e0++ {
//                         for e1 := e0 + 1; e1 &lt; vno; e1++ {
//                                 diff := diff2optD(g, path, e0, e1)
//                                 if diff &lt; bdiff {
//                                         be0, be1 = e0, e1
//                                         bdiff = diff
//                                 }
//                         }
//                 }
//                 if bdiff &lt; float32(0) {
//                         apply2opt(path, be0, be1)
//                         plen += bdiff
//                 } else {
//                         break
//                 }
//         }
//         return path, plen
// }

// Benchmark showed that the proformance gain is not worth it
// func (g *AdjMxUf32) Tsp2Opt() (path []uint, plen float32) {
//         vno := g.Order()
//         path = make([]uint, vno)
//         for i := uint(0); i+1 &lt; vno; i++ {
//                 path[i] = i
//                 plen += g.Edge(i, i+1)
//         }
//         path[vno-1] = vno - 1
//         plen += g.Edge(vno-1, 0)
//         for {
//                 be0, be1 := vno, vno
//                 bdiff := float32(0)
//                 for e0 := uint(0); e0 &lt; vno; e0++ {
//                         for e1 := e0 + 1; e1 &lt; vno; e1++ {
//                                 diff := diff2optU(g, path, e0, e1)
//                                 if diff &lt; bdiff {
//                                         be0, be1 = e0, e1
//                                         bdiff = diff
//                                 }
//                         }
//                 }
//                 if bdiff &lt; float32(0) {
//                         apply2opt(path, be0, be1)
//                         plen += bdiff
//                 } else {
//                         break
//                 }
//         }
//         return path, plen
// }
</pre>
		
		<pre class="file" id="file15" style="display: none">package tsp

import "git.fractalqb.de/fractalqb/groph"

func Greedyf32(m groph.RGf32) (path []groph.VIdx, plen float32) <span class="cov0" title="0">{
        size := m.Order()
        switch size </span>{
        case 0:<span class="cov0" title="0">
                return nil, 0</span>
        case 1:<span class="cov0" title="0">
                return []groph.VIdx{0}, 0</span>
        }
        <span class="cov0" title="0">L := size - 1
        path = make([]groph.VIdx, size)
        // start with L → 0 → 1 → … → L
        path[L] = L
        best := m.Edge(L, 0)
        for k := groph.V0; k &lt; L; k++ </span><span class="cov0" title="0">{
                path[k] = k
                best += m.Edge(k, k+1)
        }</span>
        <span class="cov0" title="0">perm := make([]groph.VIdx, L)
        copy(perm, path)
        c := make([]groph.VIdx, L) // automatic set to 0 (go!)
        i := groph.V0
        for i &lt; L </span><span class="cov0" title="0">{
                if c[i] &lt; i </span><span class="cov0" title="0">{
                        if (i &amp; 1) == 0 </span><span class="cov0" title="0">{
                                perm[0], perm[i] = perm[i], perm[0]
                        }</span> else<span class="cov0" title="0"> {
                                perm[c[i]], perm[i] = perm[i], perm[c[i]]
                        }</span>
                        <span class="cov0" title="0">curl := m.Edge(L, perm[0])
                        curl += m.Edge(perm[L-1], L)
                        for i := groph.V0; i+1 &lt; L; i++ </span><span class="cov0" title="0">{
                                curl += m.Edge(perm[i], perm[i+1])
                        }</span>
                        <span class="cov0" title="0">if curl &lt; best </span><span class="cov0" title="0">{
                                copy(path[:L], perm)
                                best = curl
                        }</span>
                        <span class="cov0" title="0">c[i]++
                        i = 0</span>
                } else<span class="cov0" title="0"> {
                        c[i] = 0
                        i++
                }</span>
        }
        <span class="cov0" title="0">return path, best</span>
}

func GreedyAdjMxDf32(m *groph.AdjMxDf32) (path []groph.VIdx, plen float32) <span class="cov8" title="1">{
        size := m.Order()
        switch size </span>{
        case 0:<span class="cov0" title="0">
                return nil, 0</span>
        case 1:<span class="cov0" title="0">
                return []groph.VIdx{0}, 0</span>
        }
        <span class="cov8" title="1">L := size - 1
        path = make([]groph.VIdx, size)
        // start with L → 0 → 1 → … → L
        path[L] = L
        best := m.Edge(L, 0)
        for k := groph.V0; k &lt; L; k++ </span><span class="cov8" title="1">{
                path[k] = k
                best += m.Edge(k, k+1)
        }</span>
        <span class="cov8" title="1">perm := make([]groph.VIdx, L)
        copy(perm, path)
        c := make([]groph.VIdx, L) // automatic set to 0 (go!)
        i := groph.V0
        for i &lt; L </span><span class="cov8" title="1">{
                if c[i] &lt; i </span><span class="cov8" title="1">{
                        if (i &amp; 1) == 0 </span><span class="cov8" title="1">{
                                perm[0], perm[i] = perm[i], perm[0]
                        }</span> else<span class="cov8" title="1"> {
                                perm[c[i]], perm[i] = perm[i], perm[c[i]]
                        }</span>
                        <span class="cov8" title="1">curl := m.Edge(L, perm[0])
                        curl += m.Edge(perm[L-1], L)
                        for i := groph.V0; i+1 &lt; L; i++ </span><span class="cov8" title="1">{
                                curl += m.Edge(perm[i], perm[i+1])
                        }</span>
                        <span class="cov8" title="1">if curl &lt; best </span><span class="cov8" title="1">{
                                copy(path[:L], perm)
                                best = curl
                        }</span>
                        <span class="cov8" title="1">c[i]++
                        i = 0</span>
                } else<span class="cov8" title="1"> {
                        c[i] = 0
                        i++
                }</span>
        }
        <span class="cov8" title="1">return path, best</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package util

import (
        "fmt"
        "math"
        "reflect"

        "git.fractalqb.de/fractalqb/groph"
)

type WeightsSlice struct {
        slc reflect.Value
        sz  groph.VIdx
}

func NewWeightsSlice(edgeSlice interface{}) *WeightsSlice <span class="cov8" title="1">{
        res := &amp;WeightsSlice{slc: reflect.ValueOf(edgeSlice)}
        res.sz = groph.VIdx(math.Sqrt(float64(res.slc.Len())))
        return res
}</span>

func (g *WeightsSlice) Check() (*WeightsSlice, error) <span class="cov0" title="0">{
        if g.slc.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return g, fmt.Errorf("edges have to be a slice, got %s",
                        g.slc.Type().String())
        }</span>
        <span class="cov0" title="0">if g.sz*g.sz != groph.VIdx(g.slc.Len()) </span><span class="cov0" title="0">{
                return g, fmt.Errorf("slice len is not quadratic")
        }</span>
        <span class="cov0" title="0">return g, nil</span>
}

func (g *WeightsSlice) Must() *WeightsSlice <span class="cov0" title="0">{
        var err error
        g, err = g.Check()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

func (g *WeightsSlice) Order() groph.VIdx <span class="cov8" title="1">{ return g.sz }</span>

func (g *WeightsSlice) Weight(u, v groph.VIdx) interface{} <span class="cov8" title="1">{
        return g.slc.Index(int(g.sz*u + v)).Interface()
}</span>

// PointsNDist implements a metric RUndirected graph based on a slice of
// vertices of some type V and a symmetric function f(u V, v V) → W that
// computes the weight of type W for any edge (u, v).
//
// From this use e.g. CpWeights or CpXWeights to initialize an other WGraph.
type PointsNDist struct {
        ps reflect.Value
        d  reflect.Value
}

func NewPointsNDist(vertexSlice interface{}, measure interface{}) *PointsNDist <span class="cov8" title="1">{
        res := &amp;PointsNDist{
                ps: reflect.ValueOf(vertexSlice),
                d:  reflect.ValueOf(measure),
        }
        return res
}</span>

// Check does type checking on g. It always returns g. Only if everything is OK
// the returned error is nil.
func (g *PointsNDist) Check() (*PointsNDist, error) <span class="cov0" title="0">{
        if g.ps.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return g, fmt.Errorf("vertex set has to be a slice, got %s",
                        g.ps.Type().String())
        }</span>
        <span class="cov0" title="0">if g.d.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return g, fmt.Errorf("edge weight measure must be a function, got: %s",
                        g.d.Type().String())
        }</span> // TODO more precise checking: func signature
        <span class="cov0" title="0">return g, nil</span>
}

// Verify call Check on g and panics if Check returns an error.
func (g *PointsNDist) Must() *PointsNDist <span class="cov0" title="0">{
        if _, err := g.Check(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

func (g *PointsNDist) Order() groph.VIdx <span class="cov8" title="1">{
        return groph.VIdx(g.ps.Len())
}</span>

func (g *PointsNDist) Vertex(idx groph.VIdx) interface{} <span class="cov8" title="1">{
        return g.ps.Index(int(idx)).Interface()
}</span>

func (g *PointsNDist) Weight(u, v groph.VIdx) interface{} <span class="cov8" title="1">{
        f, t := g.ps.Index(int(u)), g.ps.Index(int(v))
        d := g.d.Call([]reflect.Value{f, t})
        return d[0].Interface()
}</span>

func (g *PointsNDist) WeightU(u, v groph.VIdx) interface{} <span class="cov0" title="0">{ return g.Weight(u, v) }</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package util

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "strconv"
        "strings"

        "git.fractalqb.de/fractalqb/groph"
)

func WriteSparse(wr io.Writer, g groph.RGraph) error <span class="cov8" title="1">{
        fmt.Fprint(wr, "groph ")
        if groph.Directed(g) </span><span class="cov8" title="1">{
                fmt.Fprint(wr, "directed")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(wr, "undirected")
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(wr, " edges order=%d\n", g.Order())
        groph.EachEdge(g, func(u, v groph.VIdx) bool </span><span class="cov8" title="1">{
                if w := g.Weight(u, v); w != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(wr, "%d %d %v\n", u, v, w)
                }</span>
                <span class="cov8" title="1">return false</span>
        })
        <span class="cov8" title="1">return nil</span> // TODO detect errors
}

func readOdrer(prop string) (order int) <span class="cov8" title="1">{
        if !strings.HasPrefix(prop, "order=") </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">order, err := strconv.Atoi(prop[6:])
        if err != nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">return order</span>
}

type WeightParse = func(string) (interface{}, error)

func ParseI32(s string) (interface{}, error) <span class="cov8" title="1">{
        i, err := strconv.ParseInt(s, 10, 32)
        return int32(i), err
}</span>

func ReadGraph(into groph.WGraph, rd io.Reader, wParse WeightParse) error <span class="cov8" title="1">{
        scn := bufio.NewScanner(rd)
        if !scn.Scan() </span><span class="cov0" title="0">{
                return errors.New("empty input")
        }</span>
        <span class="cov8" title="1">hdr := strings.Split(scn.Text(), " ")
        if len(hdr) != 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("synax error in graph header: has %d fields, not 4", len(hdr))
        }</span>
        <span class="cov8" title="1">if hdr[0] != "groph" </span><span class="cov0" title="0">{
                return errors.New("no groph file indicator")
        }</span>
        <span class="cov8" title="1">if hdr[1] == "directed" &amp;&amp; !groph.Directed(into) </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "cannot read directed graph data into undirected graph implementaton")
        }</span>
        <span class="cov8" title="1">ord := readOdrer(hdr[3])
        if ord &lt; 0 </span><span class="cov0" title="0">{
                return errors.New("cannot read odrer of graph")
        }</span>
        <span class="cov8" title="1">into.Reset(ord)
        switch hdr[2] </span>{
        case "edges":<span class="cov8" title="1">
                return readEdges(into, scn, wParse)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown graph format: '%s'", hdr[2])</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func readEdges(g groph.WGraph, scn *bufio.Scanner, wParse WeightParse) error <span class="cov8" title="1">{
        count := 0
        for scn.Scan() </span><span class="cov8" title="1">{
                count++
                fields := strings.Split(scn.Text(), " ")
                if len(fields) != 3 </span><span class="cov0" title="0">{
                        return fmt.Errorf("syntax error in edge %d: has %d fields, not 3",
                                count,
                                len(fields))
                }</span>
                <span class="cov8" title="1">u, err := strconv.Atoi(strings.TrimSpace(fields[0]))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("syntax error in edge %d: %s", count, err)
                }</span>
                <span class="cov8" title="1">v, err := strconv.Atoi(strings.TrimSpace(fields[1]))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("syntax error in edge %d: %s", count, err)
                }</span>
                <span class="cov8" title="1">var w interface{} = fields[2]
                if wParse != nil </span><span class="cov8" title="1">{
                        w, err = wParse(fields[2])
                }</span>
                <span class="cov8" title="1">g.SetWeight(u, v, w)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package util

import (
        "git.fractalqb.de/fractalqb/groph"
)

// WeightOr returns parameter 'or' when the edge (u,v) is not in graph g.
// Otherwise the weight of edge (u,v) is returned.
func WeightOr(g groph.RGraph, u, v groph.VIdx, or interface{}) interface{} <span class="cov0" title="0">{
        if res := g.Weight(u, v); res != nil </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov0" title="0">return or</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package util

import (
        "fmt"

        "git.fractalqb.de/fractalqb/groph"
)

type MergeError struct {
        u, v groph.VIdx
        err  error
}

func (e MergeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("edges %d, %d: %s", e.u, e.v, e.err)
}</span>

func (e MergeError) Unwrap() error <span class="cov0" title="0">{ return e.err }</span>

type RUadapter struct {
        G     groph.RGraph
        Merge func(u, v groph.VIdx) (merged interface{}, err error)
        Err   error
}

func (rua *RUadapter) ErrState() error <span class="cov8" title="1">{ return rua.Err }</span>

func (rua *RUadapter) Order() groph.VIdx <span class="cov8" title="1">{ return rua.G.Order() }</span>

func (rua *RUadapter) Weight(u, v groph.VIdx) interface{} <span class="cov0" title="0">{
        return rua.WeightU(u, v)
}</span>

func (rua *RUadapter) WeightU(u, v groph.VIdx) (res interface{}) <span class="cov8" title="1">{
        var err error
        if res, err = rua.Merge(u, v); err != nil </span><span class="cov8" title="1">{
                rua.Err = MergeError{u, v, err}
        }</span>
        <span class="cov8" title="1">return res</span>
}

func MergeWeights(
        g groph.RGraph,
        merge func(w1, w2 interface{}) (merged interface{}, err error),
) func(u, v groph.VIdx) (interface{}, error) <span class="cov8" title="1">{
        return func(u, v groph.VIdx) (interface{}, error) </span><span class="cov8" title="1">{
                w1 := g.Weight(u, v)
                w2 := g.Weight(v, u)
                return merge(w1, w2)
        }</span>
}

func MergeEqual(w1, w2 interface{}) (interface{}, error) <span class="cov8" title="1">{
        if w1 == w2 </span><span class="cov8" title="1">{
                return w1, nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("not equal: '%v' / '%v'", w1, w2)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package util

import "git.fractalqb.de/fractalqb/groph"

type RSubgraph struct {
        G    groph.RGraph
        VMap []groph.VIdx
}

func (g RSubgraph) Order() groph.VIdx <span class="cov0" title="0">{
        return groph.VIdx(len(g.VMap))
}</span>

func (g RSubgraph) Weight(u, v groph.VIdx) interface{} <span class="cov0" title="0">{
        return g.Weight(g.VMap[u], g.VMap[v])
}</span>

type WSubgraph struct {
        G    groph.WGraph
        VMap []groph.VIdx
}

func (g WSubgraph) Order() groph.VIdx <span class="cov0" title="0">{
        return groph.VIdx(len(g.VMap))
}</span>

func (g WSubgraph) Weight(u, v groph.VIdx) interface{} <span class="cov0" title="0">{
        return g.Weight(g.VMap[u], g.VMap[v])
}</span>

func (g WSubgraph) Reset(order groph.VIdx) <span class="cov0" title="0">{
        panic("must not clear WSubgraph")</span>
}

func (g WSubgraph) SetWeight(u, v groph.VIdx, w interface{}) <span class="cov0" title="0">{
        g.SetWeight(g.VMap[u], g.VMap[v], w)
}</span>

// TODO Must sort vls to handle WeightU and SetWeightU?
// type RSubUndir struct {
//         g   RUndirected
//         vls []groph.VIdx
// }

// func (g RSubUndir) Order() groph.VIdx {
//         return groph.VIdx(len(g.vls))
// }

// func (g RSubUndir) Weight(u, v groph.VIdx) interface{} {
//         return g.Weight(g.vls[u], g.vls[v])
// }

// func (g RSubUndir) WeightU(u, v groph.VIdx) interface{} {
//         return g.WeightU(g.vls[u], g.vls[v])
// }

// type WSubUndir struct {
//         g   WGraph
//         vls []groph.VIdx
// }

// func (g WSubUndir) Order() groph.VIdx {
//         return groph.VIdx(len(g.vls))
// }

// func (g WSubUndir) Weight(u, v groph.VIdx) interface{} {
//         return g.Weight(g.vls[u], g.vls[v])
// }

// func (g WSubUndir) WeightU(u, v groph.VIdx) interface{} {
//         return g.WeightU(g.vls[u], g.vls[v])
// }

// func (g WSubUndir) Reset(order groph.VIdx) {
//         panic("must not clear WSubgraph")
// }

// func (g WSubUndir) SetWeight(u, v groph.VIdx, w interface{}) {
//         g.SetWeight(g.vls[u], g.vls[v], w)
// }

// func (g WSubUndir) SetWeightU(u, v groph.VIdx, w interface{}) {
//         g.SetWeight(g.vls[u], g.vls[v], w)
// }
</pre>
		
		<pre class="file" id="file21" style="display: none">package util

import (
        "fmt"
        "io"
        "strings"
        "text/tabwriter"

        "git.fractalqb.de/fractalqb/groph"
)

type GraphViz struct {
        GraphAtts   func(g groph.RGraph) map[string]interface{}
        NodeAtts    func(g groph.RGraph) map[string]interface{}
        EdgeAtts    func(g groph.RGraph) map[string]interface{}
        PerNodeAtts func(g groph.RGraph, v groph.VIdx) map[string]interface{}
        PerEdgeAtts func(g groph.RGraph, u, v groph.VIdx) map[string]interface{}
}

func (gv *GraphViz) Write(
        wr io.Writer,
        g groph.RGraph,
        name string,
        vlabels ...interface{},
) <span class="cov8" title="1">{
        if u, ok := g.(groph.RUndirected); ok </span><span class="cov0" title="0">{
                gv.uwrite(wr, u, name, vlabels)
        }</span> else<span class="cov8" title="1"> {
                gv.dwrite(wr, g, name, vlabels)
        }</span>
}

func (gv *GraphViz) nAtts(g groph.RGraph, v groph.VIdx, vlbs []interface{}) string <span class="cov8" title="1">{
        var label interface{}
        if v &lt; len(vlbs) </span><span class="cov8" title="1">{
                label = vlbs[v]
        }</span>
        <span class="cov8" title="1">var atts map[string]interface{}
        if gv.PerNodeAtts != nil </span><span class="cov8" title="1">{
                atts = gv.PerNodeAtts(g, v)
        }</span>
        <span class="cov8" title="1">var sb strings.Builder
        if label != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;sb, "label=\"%s\"", label)
                for k, att := range atts </span><span class="cov8" title="1">{
                        if k == "label" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">sb.WriteString(", ")
                        fmt.Fprintf(&amp;sb, ", %s=\"%s\"", k, att)</span>
                }
        } else<span class="cov8" title="1"> {
                sep := false
                for k, att := range atts </span><span class="cov8" title="1">{
                        if sep </span><span class="cov0" title="0">{
                                sb.WriteString(", ")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(&amp;sb, "%s=\"%s\"", k, att)
                        sep = true</span>
                }
        }
        <span class="cov8" title="1">return sb.String()</span>
}

func (gv *GraphViz) eAtts(g groph.RGraph, u, v groph.VIdx) string <span class="cov8" title="1">{
        w := g.Weight(u, v)
        if gv.PerEdgeAtts == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("label=\"%s\"", w)
        }</span>
        <span class="cov8" title="1">atts := gv.PerEdgeAtts(g, u, v)
        var sb strings.Builder
        sep := false
        if lb, ok := atts["label"]; ok </span><span class="cov8" title="1">{
                if lb != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;sb, "label=\"%s\"", lb)
                        sep = true
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Fprintf(&amp;sb, "label=\"%s\"", w)
                sep = true
        }</span>
        <span class="cov8" title="1">for k, att := range atts </span><span class="cov8" title="1">{
                if k == "label" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">if sep </span><span class="cov0" title="0">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(&amp;sb, "%s=\"%s\"", k, att)
                sep = true</span>
        }
        <span class="cov8" title="1">return sb.String()</span>
}

func (gv *GraphViz) dwrite(
        wr io.Writer,
        g groph.RGraph,
        name string,
        vlabels []interface{},
) <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                name = "G"
        }</span>
        <span class="cov8" title="1">tw := tabwriter.NewWriter(wr, 2, 0, 1, ' ', 0)
        fmt.Fprintf(tw, "digraph %s {\n", name)
        gvWriteAtts(tw, g, "graph", gv.GraphAtts)
        gvWriteAtts(tw, g, "node", gv.NodeAtts)
        gvWriteAtts(tw, g, "edge", gv.EdgeAtts)
        if len(vlabels) &gt; 0 || gv.PerNodeAtts != nil </span><span class="cov8" title="1">{
                for i := groph.V0; i &lt; g.Order(); i++ </span><span class="cov8" title="1">{
                        atts := gv.nAtts(g, i, vlabels)
                        if atts != "" </span><span class="cov8" title="1">{
                                fmt.Fprintf(tw, "\t%d\t[%s];\n", i, atts)
                        }</span>
                }
        }
        <span class="cov8" title="1">groph.EachEdge(g, func(u, v groph.VIdx) bool </span><span class="cov8" title="1">{
                atts := gv.eAtts(g, u, v)
                if atts == "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(tw, "\t%d -&gt; %d;\n", u, v)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(tw, "\t%d -&gt; %d [%s];\n", u, v, atts)
                }</span>
                <span class="cov8" title="1">return false</span>
        })
        <span class="cov8" title="1">fmt.Fprintln(tw, "}")</span>
}

func (gv *GraphViz) uwrite(
        wr io.Writer,
        g groph.RUndirected,
        name string,
        vlabels []interface{},
) <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                name = "G"
        }</span>
        <span class="cov0" title="0">tw := tabwriter.NewWriter(wr, 2, 0, 1, ' ', 0)
        fmt.Fprintf(tw, "graph %s {\n", name)
        gvWriteAtts(tw, g, "graph", gv.GraphAtts)
        gvWriteAtts(tw, g, "node", gv.NodeAtts)
        gvWriteAtts(tw, g, "edge", gv.EdgeAtts)
        if len(vlabels) &gt; 0 || gv.PerNodeAtts != nil </span><span class="cov0" title="0">{
                for i := groph.V0; i &lt; g.Order(); i++ </span><span class="cov0" title="0">{
                        atts := gv.nAtts(g, i, vlabels)
                        if atts != "" </span><span class="cov0" title="0">{
                                fmt.Fprintf(tw, "\t%d\t[%s];\n", i, atts)
                        }</span>
                }
        }
        <span class="cov0" title="0">groph.EachEdge(g, func(u, v groph.VIdx) bool </span><span class="cov0" title="0">{
                fmt.Fprintf(tw, "\t%d -- %d [label=\"%v\"];\n", u, v, g.Weight(u, v))
                return false
        }</span>)
        <span class="cov0" title="0">fmt.Fprintln(tw, "}")</span>
}

func gvWriteAtts(
        wr io.Writer,
        g groph.RGraph,
        tag string,
        attFn func(groph.RGraph) map[string]interface{},
) <span class="cov8" title="1">{
        if attFn == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">atts := attFn(g)
        if len(atts) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(wr, "\t%s\t[", tag)
                sep := false
                for k, att := range atts </span><span class="cov0" title="0">{
                        if sep </span><span class="cov0" title="0">{
                                fmt.Fprint(wr, ", ")
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(wr, "%s=\"%s\"", k, att)</span>
                }
                <span class="cov0" title="0">fmt.Fprintln(wr, "];")</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package groph

// EachOutgoing calls onDest on each vertex d where the edge (from,d) is in
// graph g.
func EachOutgoing(g RGraph, from VIdx, onDest VisitVertex) (stopped bool) <span class="cov8" title="1">{
        switch gi := g.(type) </span>{
        case OutLister:<span class="cov0" title="0">
                return gi.EachOutgoing(from, onDest)</span>
        case RUndirected:<span class="cov8" title="1">
                return eachUAdj(gi, from, onDest)</span>
        default:<span class="cov8" title="1">
                return eachDOut(g, from, onDest)</span>
        }
}

func eachDOut(g RGraph, from VIdx, onDest VisitVertex) bool <span class="cov8" title="1">{
        vno := g.Order()
        for n := V0; n &lt; vno; n++ </span><span class="cov8" title="1">{
                if g.Weight(from, n) != nil </span><span class="cov8" title="1">{
                        if onDest(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// EachIncoming calls onSource on each vertex s where the edge (s,to) is in
// graph g.
func EachIncoming(g RGraph, to VIdx, onSource VisitVertex) (stopped bool) <span class="cov8" title="1">{
        switch gi := g.(type) </span>{
        case InLister:<span class="cov0" title="0">
                return gi.EachIncoming(to, onSource)</span>
        case RUndirected:<span class="cov8" title="1">
                return eachUAdj(gi, to, onSource)</span>
        default:<span class="cov8" title="1">
                return eachDIn(g, to, onSource)</span>
        }
}

func eachDIn(g RGraph, to VIdx, onSource VisitVertex) bool <span class="cov8" title="1">{
        vno := g.Order()
        for n := V0; n &lt; vno; n++ </span><span class="cov8" title="1">{
                if g.Weight(n, to) != nil </span><span class="cov8" title="1">{
                        if onSource(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// EachAdjacent calls onOther on each vertex o where at least one of the edges
// (this,o) and (o,this) is in graph g.
func EachAdjacent(g RGraph, this VIdx, onOther VisitVertex) (stopped bool) <span class="cov0" title="0">{
        switch u := g.(type) </span>{
        case RUndirected:<span class="cov0" title="0">
                switch ls := u.(type) </span>{
                case OutLister:<span class="cov0" title="0">
                        return ls.EachOutgoing(this, onOther)</span>
                case InLister:<span class="cov0" title="0">
                        return ls.EachIncoming(this, onOther)</span>
                default:<span class="cov0" title="0">
                        return eachUAdj(u, this, onOther)</span>
                }
        case OutLister:<span class="cov0" title="0">
                if u.EachOutgoing(this, onOther) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if il, ok := g.(InLister); ok </span><span class="cov0" title="0">{
                        return il.EachIncoming(this, onOther)
                }</span> else<span class="cov0" title="0"> {
                        return eachDIn(g, this, onOther)
                }</span>
        case InLister:<span class="cov0" title="0">
                if u.EachIncoming(this, onOther) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if ol, ok := g.(OutLister); ok </span><span class="cov0" title="0">{
                        return ol.EachOutgoing(this, onOther)
                }</span> else<span class="cov0" title="0"> {
                        return eachDOut(g, this, onOther)
                }</span>
        default:<span class="cov0" title="0">
                return eachDAdj(g, this, onOther)</span>
        }
}

func eachDAdj(g RGraph, v VIdx, on VisitVertex) bool <span class="cov0" title="0">{
        ord := g.Order()
        for u := V0; u &lt; ord; u++ </span><span class="cov0" title="0">{
                if g.Weight(v, u) != nil || g.Weight(u, v) != nil </span><span class="cov0" title="0">{
                        if on(u) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func eachUAdj(u RUndirected, v VIdx, on VisitVertex) bool <span class="cov8" title="1">{
        vno := u.Order()
        n := V0
        for n &lt; v </span><span class="cov8" title="1">{
                if u.WeightU(v, n) != nil </span><span class="cov8" title="1">{
                        if on(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">for n &lt; vno </span><span class="cov8" title="1">{
                if u.WeightU(n, v) != nil </span><span class="cov8" title="1">{
                        if on(n) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">return false</span>
}

// EachEdge call onEdge for every edge in graph g.
func EachEdge(g RGraph, onEdge VisitEdge) (stopped bool) <span class="cov8" title="1">{
        // TODO optimize with In-/OutLister
        switch ge := g.(type) </span>{
        case EdgeLister:<span class="cov0" title="0">
                return ge.EachEdge(onEdge)</span>
        case RUndirected:<span class="cov8" title="1">
                vno := ge.Order()
                for i := V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := V0; j &lt;= i; j++ </span><span class="cov8" title="1">{
                                if w := ge.WeightU(i, j); w != nil </span><span class="cov8" title="1">{
                                        if onEdge(i, j) </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
        default:<span class="cov8" title="1">
                vno := g.Order()
                for i := V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                if w := g.Weight(i, j); w != nil </span><span class="cov8" title="1">{
                                        if onEdge(i, j) </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
