
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">git.fractalqb.de/fractalqb/groph/adapt.go (22.6%)</option>
				
				<option value="file1">git.fractalqb.de/fractalqb/groph/adjmatrix.go (69.2%)</option>
				
				<option value="file2">git.fractalqb.de/fractalqb/groph/bitset.go (84.2%)</option>
				
				<option value="file3">git.fractalqb.de/fractalqb/groph/graph.go (70.6%)</option>
				
				<option value="file4">git.fractalqb.de/fractalqb/groph/internal/test/d2graph.go (0.0%)</option>
				
				<option value="file5">git.fractalqb.de/fractalqb/groph/internal/util/slices.go (20.0%)</option>
				
				<option value="file6">git.fractalqb.de/fractalqb/groph/minspantree/kruskal.go (81.8%)</option>
				
				<option value="file7">git.fractalqb.de/fractalqb/groph/shortestpath/dijkstra.go (98.9%)</option>
				
				<option value="file8">git.fractalqb.de/fractalqb/groph/shortestpath/floyd_warshall.go (80.7%)</option>
				
				<option value="file9">git.fractalqb.de/fractalqb/groph/sliceofmap.go (57.1%)</option>
				
				<option value="file10">git.fractalqb.de/fractalqb/groph/subgraph.go (0.0%)</option>
				
				<option value="file11">git.fractalqb.de/fractalqb/groph/tsp/2opt.go (100.0%)</option>
				
				<option value="file12">git.fractalqb.de/fractalqb/groph/tsp/greedy.go (46.9%)</option>
				
				<option value="file13">git.fractalqb.de/fractalqb/groph/undiradapt.go (52.4%)</option>
				
				<option value="file14">git.fractalqb.de/fractalqb/groph/util/copy.go (20.3%)</option>
				
				<option value="file15">git.fractalqb.de/fractalqb/groph/util/readasundir.go (86.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package groph

import (
        "fmt"
        "math"
        "reflect"
)

type WeightsSlice struct {
        slc reflect.Value
        sz  VIdx
}

func NewWeightsSlice(edgeSlice interface{}) *WeightsSlice <span class="cov0" title="0">{
        res := &amp;WeightsSlice{slc: reflect.ValueOf(edgeSlice)}
        res.sz = VIdx(math.Sqrt(float64(res.slc.Len())))
        return res
}</span>

func (g *WeightsSlice) Check() (*WeightsSlice, error) <span class="cov0" title="0">{
        if g.slc.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return g, fmt.Errorf("edges have to be a slice, got %s",
                        g.slc.Type().String())
        }</span>
        <span class="cov0" title="0">if g.sz*g.sz != VIdx(g.slc.Len()) </span><span class="cov0" title="0">{
                return g, fmt.Errorf("slice len is not quadratic")
        }</span>
        <span class="cov0" title="0">return g, nil</span>
}

func (g *WeightsSlice) Must() *WeightsSlice <span class="cov0" title="0">{
        var err error
        g, err = g.Check()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

func (g *WeightsSlice) VertexNo() VIdx <span class="cov0" title="0">{ return g.sz }</span>

func (g *WeightsSlice) Weight(u, v VIdx) interface{} <span class="cov0" title="0">{
        return g.slc.Index(int(g.sz*u + v)).Interface()
}</span>

// PointsNDist implements a metric RUndirected graph based on a slice of
// vertices of some type V and a symmetric function f(u V, v V) → W that
// computes the weight of type W for any edge (u, v).
//
// From this use e.g. CpWeights or CpXWeights to initialize an other WGraph.
type PointsNDist struct {
        ps reflect.Value
        d  reflect.Value
}

func NewPointsNDist(vertexSlice interface{}, measure interface{}) *PointsNDist <span class="cov8" title="1">{
        res := &amp;PointsNDist{
                ps: reflect.ValueOf(vertexSlice),
                d:  reflect.ValueOf(measure),
        }
        return res
}</span>

// Check does type checking on g. It always returns g. Only if everything is OK
// the returned error is nil.
func (g *PointsNDist) Check() (*PointsNDist, error) <span class="cov0" title="0">{
        if g.ps.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return g, fmt.Errorf("vertex set has to be a slice, got %s",
                        g.ps.Type().String())
        }</span>
        <span class="cov0" title="0">if g.d.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return g, fmt.Errorf("edge weight measure must be a function, got: %s",
                        g.d.Type().String())
        }</span> // TODO more precise checking: func signature
        <span class="cov0" title="0">return g, nil</span>
}

// Verify call Check on g and panics if Check returns an error.
func (g *PointsNDist) Must() *PointsNDist <span class="cov0" title="0">{
        if _, err := g.Check(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

func (g *PointsNDist) VertexNo() VIdx <span class="cov8" title="1">{
        return VIdx(g.ps.Len())
}</span>

func (g *PointsNDist) Vertex(idx VIdx) interface{} <span class="cov8" title="1">{
        return g.ps.Index(int(idx)).Interface()
}</span>

func (g *PointsNDist) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        f, t := g.ps.Index(int(u)), g.ps.Index(int(v))
        d := g.d.Call([]reflect.Value{f, t})
        return d[0].Interface()
}</span>

func (g *PointsNDist) WeightU(u, v VIdx) interface{} <span class="cov0" title="0">{ return g.Weight(u, v) }</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package groph

import (
        "math"

        iutil "git.fractalqb.de/fractalqb/groph/internal/util"
)

type adjMx struct {
        sz VIdx
}

func (m *adjMx) VertexNo() VIdx <span class="cov8" title="1">{ return m.sz }</span>

// AdjMxDbitmap is a directed WGraph with boolean edge weights implemented as
// bitmap. This sacrifices runtime performance for lesser memory usage.
type AdjMxDbitmap struct {
        adjMx
        bs BitSet
}

func NewAdjMxDbitmap(vertexNo VIdx, reuse *AdjMxDbitmap) *AdjMxDbitmap <span class="cov8" title="1">{
        sz := vertexNo * vertexNo
        sz = BitSetWords(sz)
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDbitmap{
                        adjMx: adjMx{sz: vertexNo},
                        bs:    make(BitSet, sz),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.bs = iutil.U64Slice(reuse.bs, int(sz))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDbitmap) Init(flag bool) *AdjMxDbitmap <span class="cov0" title="0">{
        if flag </span><span class="cov0" title="0">{
                for i := range m.bs </span><span class="cov0" title="0">{
                        m.bs[i] = ^uint64(0)
                }</span>
        } else<span class="cov0" title="0"> {
                for i := range m.bs </span><span class="cov0" title="0">{
                        m.bs[i] = 0
                }</span>
        }
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDbitmap) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxDbitmap(vertexNo, m)
        m.Init(false)
}</span>

func (m *AdjMxDbitmap) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if m.Edge(u, v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDbitmap) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, false)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(bool))
        }</span>
}

func (m *AdjMxDbitmap) Edge(i, j VIdx) (w bool) <span class="cov8" title="1">{
        w = m.bs.Get(m.sz*i + j)
        return w
}</span>

func (m *AdjMxDbitmap) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        if w </span><span class="cov8" title="1">{
                m.bs.Set(m.sz*i + j)
        }</span> else<span class="cov8" title="1"> {
                m.bs.Unset(m.sz*i + j)
        }</span>
}

type AdjMxDbool struct {
        adjMx
        bs []bool
}

func NewAdjMxDbool(vertexNo VIdx, reuse *AdjMxDbool) *AdjMxDbool <span class="cov8" title="1">{
        sz := vertexNo * vertexNo
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDbool{
                        adjMx: adjMx{sz: vertexNo},
                        bs:    make([]bool, sz),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.bs = iutil.BoolSlice(reuse.bs, int(sz))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDbool) Init(flag bool) *AdjMxDbool <span class="cov0" title="0">{
        for i := range m.bs </span><span class="cov0" title="0">{
                m.bs[i] = flag
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDbool) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxDbool(vertexNo, m)
        m.Init(false)
}</span>

func (m *AdjMxDbool) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if m.Edge(u, v) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDbool) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, false)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(bool))
        }</span>
}

func (m *AdjMxDbool) Edge(i, j VIdx) (w bool) <span class="cov8" title="1">{
        return m.bs[m.sz*i+j]
}</span>

func (m *AdjMxDbool) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        m.bs[m.sz*i+j] = w
}</span>

type AdjMxDi32 struct {
        adjMx
        w   []int32
        Del int32
}

func NewAdjMxDi32(vertexNo VIdx, reuse *AdjMxDi32) *AdjMxDi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDi32{
                        adjMx: adjMx{sz: vertexNo},
                        w:     make([]int32, vertexNo*vertexNo),
                        Del:   i32cleared,
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = iutil.I32Slice(reuse.w, int(vertexNo*vertexNo))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDi32) Init(w int32) *AdjMxDi32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDi32) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        c := m.Del
        NewAdjMxDi32(vertexNo, m)
        m.Del = c
        m.Init(m.Del)
}</span>

func (m *AdjMxDi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        res, ok := m.Edge(u, v)
        if ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDi32) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.DelEdge(i, j)
        }</span> else<span class="cov8" title="1"> {
                m.w[m.sz*i+j] = w.(int32)
        }</span>
}

func (m *AdjMxDi32) Edge(i, j VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        w = m.w[m.sz*i+j]
        return w, w != m.Del
}</span>

func (m *AdjMxDi32) SetEdge(i, j VIdx, w int32) <span class="cov8" title="1">{
        m.w[m.sz*i+j] = w
}</span>

func (m *AdjMxDi32) DelEdge(i, j VIdx) <span class="cov8" title="1">{
        m.SetEdge(i, j, m.Del)
}</span>

type AdjMxDf32 struct {
        adjMx
        w []float32
}

func NewAdjMxDf32(vertexNo VIdx, reuse *AdjMxDf32) *AdjMxDf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDf32{
                        adjMx: adjMx{sz: vertexNo},
                        w:     make([]float32, vertexNo*vertexNo),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = iutil.F32Slice(reuse.w, int(vertexNo*vertexNo))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDf32) Init(w float32) *AdjMxDf32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDf32) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxDf32(vertexNo, m)
        m.Init(nan32)
}</span>

func (m *AdjMxDf32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        w := m.Edge(u, v)
        if math.IsNaN(float64(w)) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return w
        }</span>
}

func (m *AdjMxDf32) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.w[m.sz*i+j] = nan32
        }</span> else<span class="cov8" title="1"> {
                m.w[m.sz*i+j] = w.(float32)
        }</span>
}

func (m *AdjMxDf32) Edge(i, j VIdx) (w float32) <span class="cov8" title="1">{
        return m.w[m.sz*i+j]
}</span>

func (m *AdjMxDf32) SetEdge(i, j VIdx, w float32) <span class="cov8" title="1">{
        m.w[m.sz*i+j] = w
}</span>

// uSum computes the sum of the n 1st integers, i.e. 1+2+3+…+n
func nSum(n VIdx) VIdx <span class="cov8" title="1">{ return n * (n + 1) / 2 }</span>

func nSumRev(n VIdx) float64 <span class="cov0" title="0">{
        r := math.Sqrt(0.25 + 2*float64(n))
        return r - 0.5
}</span>

type AdjMxUf32 struct {
        adjMx
        w []float32
}

func NewAdjMxUf32(vertexNo VIdx, reuse *AdjMxUf32) *AdjMxUf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUf32{
                        adjMx: adjMx{sz: vertexNo},
                        w:     make([]float32, nSum(vertexNo)),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = iutil.F32Slice(reuse.w, int(nSum(vertexNo)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxUf32) Init(w float32) *AdjMxUf32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxUf32) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxUf32(vertexNo, m)
        m.Init(nan32)
}</span>

// uIdx computes the index into the weight slice of an undirected matrix
func uIdx(i, j VIdx) VIdx <span class="cov8" title="1">{ return nSum(i) + j }</span>

func (m *AdjMxUf32) Weight(i, j VIdx) interface{} <span class="cov8" title="1">{
        w := m.Edge(i, j)
        if math.IsNaN(float64(w)) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return w
        }</span>
}

func (m *AdjMxUf32) WeightU(i, j VIdx) interface{} <span class="cov8" title="1">{
        w := m.EdgeU(i, j)
        if math.IsNaN(float64(w)) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return w
        }</span>
}

func (m *AdjMxUf32) SetWeight(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdge(i, j, NaN32())
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(i, j, w.(float32))
        }</span>
}

func (m *AdjMxUf32) SetWeightU(i, j VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.SetEdgeU(i, j, NaN32())
        }</span> else<span class="cov8" title="1"> {
                m.SetEdgeU(i, j, w.(float32))
        }</span>
}

func (m *AdjMxUf32) Edge(i, j VIdx) (w float32) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                return m.w[uIdx(i, j)]
        }</span> else<span class="cov8" title="1"> {
                return m.w[uIdx(j, i)]
        }</span>
}

// EdgeU is used iff i &gt;= j
func (m *AdjMxUf32) EdgeU(i, j VIdx) (w float32) <span class="cov8" title="1">{
        return m.w[uIdx(i, j)]
}</span>

func (m *AdjMxUf32) SetEdge(i, j VIdx, w float32) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                m.w[uIdx(i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.w[uIdx(j, i)] = w
        }</span>
}

// SetEdgeU is used iff i &gt;= j
func (m *AdjMxUf32) SetEdgeU(i, j VIdx, w float32) <span class="cov8" title="1">{
        m.w[uIdx(i, j)] = w
}</span>

type AdjMxUi32 struct {
        adjMx
        w   []int32
        Del int32
}

func NewAdjMxUi32(vertexNo VIdx, reuse *AdjMxUi32) *AdjMxUi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUi32{
                        adjMx: adjMx{sz: vertexNo},
                        w:     make([]int32, nSum(vertexNo)),
                        Del:   i32cleared,
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = iutil.I32Slice(reuse.w, int(nSum(vertexNo)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxUi32) Init(w int32) *AdjMxUi32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxUi32) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxUi32(vertexNo, m)
        m.Init(m.Del)
}</span>

func (m *AdjMxUi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if w, ok := m.Edge(u, v); ok </span><span class="cov8" title="1">{
                return w
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxUi32) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{
        w, ok := m.EdgeU(u, v)
        if ok </span><span class="cov8" title="1">{
                return w
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxUi32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.DelEdge(u, v)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdge(u, v, w.(int32))
        }</span>
}

func (m *AdjMxUi32) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                m.DelEdgeU(u, v)
        }</span> else<span class="cov8" title="1"> {
                m.SetEdgeU(u, v, w.(int32))
        }</span>
}

func (m *AdjMxUi32) DelEdge(u, v VIdx) <span class="cov8" title="1">{
        m.SetEdge(u, v, m.Del)
}</span>

func (m *AdjMxUi32) DelEdgeU(u, v VIdx) <span class="cov8" title="1">{
        m.SetEdgeU(u, v, m.Del)
}</span>

func (m *AdjMxUi32) Edge(u, v VIdx) (w int32, ok bool) <span class="cov8" title="1">{
        if u &gt;= v </span><span class="cov8" title="1">{
                w = m.w[uIdx(u, v)]
        }</span> else<span class="cov8" title="1"> {
                w = m.w[uIdx(v, u)]
        }</span>
        <span class="cov8" title="1">return w, w != m.Del</span>
}

// EdgeU is used iff i &gt;= j
func (m *AdjMxUi32) EdgeU(u, v VIdx) (w int32, ok bool) <span class="cov8" title="1">{
        w = m.w[uIdx(u, v)]
        return w, w != m.Del
}</span>

func (m *AdjMxUi32) SetEdge(i, j VIdx, w int32) <span class="cov8" title="1">{
        if i &gt;= j </span><span class="cov8" title="1">{
                m.w[uIdx(i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.w[uIdx(j, i)] = w
        }</span>
}

// SetEdgeU is used iff i &gt;= j
func (m *AdjMxUi32) SetEdgeU(u, v VIdx, w int32) <span class="cov8" title="1">{
        m.w[uIdx(u, v)] = w
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package groph

type bitsWord = uint64

const (
        wordAll = 0xffff_ffff_ffff_ffff
        wordBits  = 64
        wordMask  = 0x3f
        wordShift = 6
)

type BitSet []bitsWord

func BitSetWords(setSize int) int <span class="cov8" title="1">{
        return (setSize + (wordBits - 1)) / wordBits
}</span>

func NewBitSet(setSize int) BitSet <span class="cov0" title="0">{ return make(BitSet, BitSetWords(setSize))}</span>

func (bs BitSet) Cap() int <span class="cov8" title="1">{ return len(bs) * wordBits }</span>

func (bs BitSet) Get(i int) bool <span class="cov8" title="1">{
        w, b := i&gt;&gt;wordShift, i&amp;wordMask
        return bs[w]&amp;(1&lt;&lt;b) != 0
}</span>

func (bs BitSet) Set(i int) <span class="cov8" title="1">{
        w, b := i&gt;&gt;wordShift, i&amp;wordMask
        bs[w] |= 1 &lt;&lt; b
}</span>

func (bs BitSet) Unset(i int) <span class="cov8" title="1">{
        w, b := i&gt;&gt;wordShift, i&amp;wordMask
        bs[w] &amp;= ^(1 &lt;&lt; b)
}</span>

func (bs BitSet) Clear() <span class="cov0" title="0">{
        for i := range bs </span><span class="cov0" title="0">{
                bs[i] = 0
        }</span>
}

func (bs BitSet) FirstUnset() (res int) <span class="cov8" title="1">{
        var w bitsWord
        for res, w = range bs </span><span class="cov8" title="1">{
                if w != wordAll </span><span class="cov8" title="1">{
                        res *= wordBits                        
                        for b := bitsWord(1); w&amp;b == b; b &lt;&lt;= 1 </span><span class="cov8" title="1">{
                                res++
                        }</span>
                        <span class="cov8" title="1">return res</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package groph

import (
        "math"
        "reflect"
)

// VIdx is the type used to represent vertices in the graph implementations
// provided by the groph package.
type VIdx = int

const V0 VIdx = 0

// Edge represents a graphs edge between vertices U and V. For directed graphs
// its the edge from U to V.
type Edge struct {
        U, V VIdx
}

// RGraph represents graph that allows read only access to the egde
// weights.
//
// For graphs that can change be modified see WGraph. For undirected
// graphs see also RUndirected.
type RGraph interface {
        // VertextNo return the numer of vertices in the graph.
        VertexNo() VIdx
        // Returns the weight of the edge that connects the vertex with index
        // u with the vertex with index v. If there is no such edge it returns nil.
        Weight(u, v VIdx) interface{}
}

func WeightOr(g RGraph, u, v VIdx, or interface{}) interface{} <span class="cov0" title="0">{
        if res := g.Weight(u, v); res != nil </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov0" title="0">return or</span>
}

// RUndirected represents an undirected graph that allows read only
// access to the edge weights.
type RUndirected interface {
        RGraph
        // Weight must only be called when u ≥ v.  Otherwise WeightU's
        // behaviour is unspecified, it even might crash.  In many
        // implementations this can be way more efficient than the
        // general case, see method Weight().
        WeightU(u, v VIdx) interface{}
}

// Directed returns true, iff g is a directed graph and false otherwise.
func Directed(g RGraph) bool <span class="cov8" title="1">{
        _, ok := g.(RUndirected)
        return !ok
}</span>

type VisitVertex = func(neighbour VIdx)

// OutLister is implemented by graph implementations that can easily iterate
// over all outgoing edges of one node.
//
// See also traverse.EachOutgoing function.
type OutLister interface {
        EachOutgoing(from VIdx, onDest VisitVertex)
        OutDegree(v VIdx) int
}

// InLister is implemented by graph implementations that can easily iterate
// over all incoming edges of one node.
//
// See also EachIncoming function.
type InLister interface {
        EachIncoming(to VIdx, onSource VisitVertex)
        InDegree(v VIdx) int
}

// WGraph represents graph that allows read and write access to the
// egde weights.
//
// For undirected graphs see also WUndirected.
type WGraph interface {
        RGraph
        // Reset resizes the graph to vertexNo and reinitializes it. Implementations
        // are expected to reuse memory.
        Reset(vertexNo VIdx)
        // SetWeight sets the edge weight for the edge starting at vertex u and
        // ending at vertex v. Passing w==nil removes the edge.
        SetWeight(u, v VIdx, w interface{})
}

// WUndirected represents an undirected graph that allows read and
// write access to the egde weights.
type WUndirected interface {
        WGraph
        // See RUndirected.WeightU
        WeightU(u, v VIdx) interface{}
        // SetWeightU must only be called when u ≥ v.  Otherwise
        // SetWeightU's behaviour is unspecified, it even might crash.
        //
        // See also RUndirected.WeightU
        SetWeightU(u, v VIdx, w interface{})
}

// Reset clears a WGraph while keeping the original vertexNo.
func Reset(g WGraph) <span class="cov0" title="0">{ g.Reset(g.VertexNo()) }</span>

// RGbool represents a RGraph with boolean edge weights.
type RGbool interface {
        RGraph
        // Edge returns true, iff the edge (u,v) is in the graph.
        Edge(u, v VIdx) bool
}

// RUbool represents a RUndirected with boolean edge weights.
type RUbool interface {
        RGbool
        EdgeU(u, v VIdx) bool
}

// WGbool represents a WGraph with boolean edge weights.
type WGbool interface {
        WGraph
        // see RGbool
        Edge(u, v VIdx) bool
        // SetEdge removes the edge (u,v) from the graph when flag == bool.
        // Otherwise it adds the edge (u,v) to the graph.
        SetEdge(u, v VIdx, flag bool)
}

type WUbool interface {
        WGbool
        WeightU(u, v VIdx) interface{}
        SetWeightU(u, v VIdx, w interface{})
        EdgeU(u, v VIdx) bool
        SetEdgeU(u, v VIdx, flag bool)
}

// An RGi32 is a RGraph with type safe access to the edge weight of type
// int32. Besides type safety this avoids boxing/unboxing of the Weight
// method for performance reasons.
type RGi32 interface {
        RGraph
        // Edge returns ok == true, iff the edge (u,v) is in the graph. Then it will
        // also return the weight of the edge. Otherwise the value of weight is
        // unspecified.
        Edge(u, v VIdx) (weight int32, ok bool)
}

type RUi32 interface {
        RGi32
        EdgeU(u, v VIdx) (weight int32, ok bool)
}

// An WGi32 is to WGraph what RGi32 is to RGraph.
type WGi32 interface {
        WGraph
        // see RGi32
        Edge(u, v VIdx) (weight int32, ok bool)
        // SetEdge sets the weight of the edge (u,v). If the edge (u,v) was not in
        // the graph before, it is implicitly added.
        SetEdge(u, v VIdx, weight int32)
        // DelEdge deletes the edge (u,v) from the graph.
        DelEdge(u, v VIdx)
}

type WUi32 interface {
        WGi32
        WeightU(u, v VIdx) interface{}
        SetWeightU(u, v VIdx, w interface{})
        EdgeU(u, v VIdx) (weight int32, ok bool)
        SetEdgeU(u, v VIdx, weight int32)
}

var nan32 = float32(math.NaN())

func NaN32() float32 <span class="cov8" title="1">{ return nan32 }</span>

func IsNaN32(x float32) bool <span class="cov8" title="1">{ return math.IsNaN(float64(x)) }</span>

// An RGf32 is a RGraph with type safe access to the edge weight of type
// float32. Besides type safety this avoids boxing/unboxing of the Weight
// method for performance reasons.
type RGf32 interface {
        RGraph
        // Edge returns Nan32() when the edge (u,v) is not in the graph. Otherwise
        // it returns the weight of the edge.
        Edge(u, v VIdx) (weight float32)
}

type RUf32 interface {
        RGf32
        EdgeU(u, v VIdx) (weight float32)
}

// An WGf32 is to WGraph what RGf32 is to RGraph.
type WGf32 interface {
        WGraph
        // see RGf32
        Edge(u, v VIdx) (weight float32)
        // SetEdge removes the edge (u,v) from the graph, iff weight is NaN32().
        // Othwerwise it sets the weight of the edge to weight.
        SetEdge(u, v VIdx, weight float32)
}

type WUf32 interface {
        WGf32
        WeightU(u, v VIdx) interface{}
        SetWeightU(u, v VIdx, w interface{})
        EdgeU(u, v VIdx) (weight float32)
        SetEdgeU(u, v VIdx, weight float32)
}

// TODO can this be done in place?
func ReorderPath(slice interface{}, path []VIdx) <span class="cov8" title="1">{
        slv := reflect.ValueOf(slice)
        if slv.Len() == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tmp := make([]interface{}, slv.Len())
        for i := 0; i &lt; slv.Len(); i++ </span><span class="cov8" title="1">{
                tmp[i] = slv.Index(i).Interface()
        }</span>
        <span class="cov8" title="1">for w, r := range path </span><span class="cov8" title="1">{
                v := tmp[r]
                slv.Index(w).Set(reflect.ValueOf(v))
        }</span>
}

const i32cleared = -2147483648 // min{ int32 }
</pre>
		
		<pre class="file" id="file4" style="display: none">package test

import (
        "math"
        "math/rand"

        "git.fractalqb.de/fractalqb/groph"
)

type Point [2]float32

func Dist(p, q Point) float32 <span class="cov0" title="0">{
        d1 := p[0] - q[0]
        d2 := p[1] - q[1]
        return float32(math.Sqrt(float64(d1*d1 + d2*d2)))
}</span>

func RandomPoints(n groph.VIdx, ps []Point) []Point <span class="cov0" title="0">{
        if groph.VIdx(cap(ps)) &gt;= n </span><span class="cov0" title="0">{
                ps = ps[:n-1]
        }</span> else<span class="cov0" title="0"> {
                ps = make([]Point, n)
        }</span>
        <span class="cov0" title="0">for i := range ps </span><span class="cov0" title="0">{
                ps[i][0] = rand.Float32()
                ps[i][1] = rand.Float32()
        }</span>
        <span class="cov0" title="0">return ps</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package util

var VIdxSlice = IntSlice

func BoolSlice(s []bool, l int) []bool <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]bool, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func IntSlice(s []int, l int) []int <span class="cov8" title="1">{
        if s == nil || cap(s) &lt; l </span><span class="cov8" title="1">{
                return make([]int, l)
        }</span>
        <span class="cov8" title="1">return s[:l]</span>
}

func I32Slice(s []int32, l int) []int32 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]int32, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func U64Slice(s []uint64, l int) []uint64 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]uint64, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func F32Slice(s []float32, l int) []float32 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]float32, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package minspantree

import (
        "errors"
        "math"
        "sort"

        "git.fractalqb.de/fractalqb/groph"
)

func sortedEdges(g groph.RGf32) (res []groph.Edge) <span class="cov8" title="1">{
        vno := g.VertexNo()
        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; vno; j++ </span><span class="cov8" title="1">{
                        if !math.IsNaN(float64(g.Edge(i, j))) </span><span class="cov8" title="1">{
                                res = append(res, groph.Edge{i, j})
                        }</span>
                }
        }
        <span class="cov8" title="1">sort.Slice(res, func(i, j int) bool </span><span class="cov8" title="1">{
                e1, e2 := &amp;res[i], &amp;res[j]
                return g.Edge(e1.U, e1.V) &lt; g.Edge(e2.U, e2.V)
        }</span>)
        <span class="cov8" title="1">return res</span>
}

// TODO more efficient way for bookkeping of connected sets?
func retag(f map[groph.VIdx]groph.VIdx, oldTag, newTag groph.VIdx) <span class="cov8" title="1">{
        for v, t := range f </span><span class="cov8" title="1">{
                if t == oldTag </span><span class="cov8" title="1">{
                        f[v] = newTag
                }</span>
        }
}

func Kruskalf32(g groph.RGf32, mst []groph.Edge) ([]groph.Edge, error) <span class="cov8" title="1">{
        if groph.Directed(g) </span><span class="cov0" title="0">{
                return mst, errors.New("cannot apply Kruskal's algorithm to directed graphs")
        }</span>
        <span class="cov8" title="1">mst = mst[:0]
        ebo := sortedEdges(g)
        frs := make(map[groph.VIdx]groph.VIdx)
        vc := groph.V0
        for _, e := range ebo </span><span class="cov8" title="1">{
                ti, iOk := frs[e.U]
                tj, jOk := frs[e.V]
                if iOk </span><span class="cov8" title="1">{
                        if jOk </span><span class="cov8" title="1">{ // no new vertex
                                if ti != tj </span><span class="cov8" title="1">{
                                        retag(frs, ti, tj)
                                        mst = append(mst, e)
                                }</span>
                        } else<span class="cov8" title="1"> { // j is new vertex
                                frs[e.V] = ti
                                mst = append(mst, e)
                                vc++
                                if vc == g.VertexNo() </span><span class="cov8" title="1">{
                                        return mst, nil
                                }</span>
                        }
                } else<span class="cov8" title="1"> if jOk </span><span class="cov0" title="0">{ // i is new vertex
                        frs[e.U] = tj
                        mst = append(mst, e)
                        vc++
                        if vc == g.VertexNo() </span><span class="cov0" title="0">{
                                return mst, nil
                        }</span>
                } else<span class="cov8" title="1"> { // i &amp; j are new vertices
                        frs[e.U] = e.U
                        frs[e.V] = e.U
                        mst = append(mst, e)
                        vc += 2
                        if vc == g.VertexNo() </span><span class="cov0" title="0">{
                                return mst, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return mst, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package shortestpath

import (
        "container/heap"
        "math"

        "git.fractalqb.de/fractalqb/groph"
        iutil "git.fractalqb.de/fractalqb/groph/internal/util"
        "git.fractalqb.de/fractalqb/groph/traverse"
)

type pqItemi32 struct {
        v groph.VIdx
        p int32
}

type Dijkstrai32 struct {
        v2i []int
        is  []pqItemi32
}

func (dij *Dijkstrai32) init(vno int) <span class="cov8" title="1">{
        dij.v2i = iutil.IntSlice(dij.v2i, vno)
        if dij.is == nil || cap(dij.is) &lt; vno </span><span class="cov8" title="1">{
                dij.is = make([]pqItemi32, 0, vno)
        }</span> else<span class="cov8" title="1"> {
                dij.is = dij.is[:0]
        }</span>
}

func (pq *Dijkstrai32) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *Dijkstrai32) Less(i, j int) bool <span class="cov8" title="1">{
        pi, pj := pq.is[i].p, pq.is[j].p
        if pi &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if pj &lt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return pi &lt; pj</span>
}

func (pq *Dijkstrai32) Swap(i, j int) <span class="cov8" title="1">{
        ii, ij := pq.is[i], pq.is[j]
        pq.v2i[ii.v], pq.v2i[ij.v] = j, i
        pq.is[i], pq.is[j] = ij, ii
}</span>

func (pq *Dijkstrai32) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(pqItemi32)
        pq.v2i[item.v] = len(pq.is)
        pq.is = append(pq.is, item)
}</span>

func (pq *Dijkstrai32) Pop() interface{} <span class="cov8" title="1">{
        n := len(pq.is) - 1
        res := pq.is[n]
        pq.is = pq.is[:n]
        return res
}</span>

func (pq *Dijkstrai32) update(v groph.VIdx, priority int32) <span class="cov8" title="1">{
        i := pq.v2i[v]
        pq.is[i].p = priority
        heap.Fix(pq, i)
}</span>

func (dij *Dijkstrai32) On(
        g groph.RGi32,
        start groph.VIdx,
        dist []int32,
        prev []groph.VIdx,
) ([]int32, []groph.VIdx) <span class="cov8" title="1">{
        vertexNo := g.VertexNo()
        dist = iutil.I32Slice(dist, vertexNo)
        if prev != nil </span><span class="cov8" title="1">{
                prev = iutil.VIdxSlice(prev, vertexNo)
        }</span>
        <span class="cov8" title="1">dij.init(vertexNo)
        dist[start] = 0
        for v := groph.V0; v &lt; g.VertexNo(); v++ </span><span class="cov8" title="1">{
                if v != start </span><span class="cov8" title="1">{
                        dist[v] = -1
                }</span>
                <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                        prev[v] = -1
                }</span>
                <span class="cov8" title="1">heap.Push(dij, pqItemi32{v, dist[v]})</span>
        }
        <span class="cov8" title="1">for dij.Len() != 0 </span><span class="cov8" title="1">{
                u := heap.Pop(dij).(pqItemi32).v
                traverse.EachOutgoing(g, u, func(n groph.VIdx) </span><span class="cov8" title="1">{
                        alt := dist[u]
                        if alt &lt; 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">e, _ := g.Edge(u, n) // TODO EdgeD?
                        alt += e
                        if dist[n] &lt; 0 || alt &lt; dist[n] </span><span class="cov8" title="1">{
                                dist[n] = alt
                                if prev != nil </span><span class="cov8" title="1">{
                                        prev[n] = u
                                }</span>
                                <span class="cov8" title="1">dij.update(n, alt)</span>
                        }
                })
        }
        <span class="cov8" title="1">return dist, prev</span>
}

type pqItemf32 struct {
        v groph.VIdx
        p float32
}

type Dijkstraf32 struct {
        v2i []int
        is  []pqItemf32
}

func (dij *Dijkstraf32) init(vno int) <span class="cov8" title="1">{
        dij.v2i = iutil.IntSlice(dij.v2i, vno)
        if dij.is == nil || cap(dij.is) &lt; vno </span><span class="cov8" title="1">{
                dij.is = make([]pqItemf32, 0, vno)
        }</span> else<span class="cov8" title="1"> {
                dij.is = dij.is[:0]
        }</span>
}

func (pq *Dijkstraf32) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *Dijkstraf32) Less(i, j int) bool <span class="cov8" title="1">{ return pq.is[i].p &lt; pq.is[j].p }</span>

func (pq *Dijkstraf32) Swap(i, j int) <span class="cov8" title="1">{
        ii, ij := pq.is[i], pq.is[j]
        pq.v2i[ii.v], pq.v2i[ij.v] = j, i
        pq.is[i], pq.is[j] = ij, ii
}</span>

func (pq *Dijkstraf32) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(pqItemf32)
        pq.v2i[item.v] = len(pq.is)
        pq.is = append(pq.is, item)
}</span>

func (pq *Dijkstraf32) Pop() interface{} <span class="cov8" title="1">{
        n := len(pq.is) - 1
        res := pq.is[n]
        pq.is = pq.is[:n]
        return res
}</span>

func (pq *Dijkstraf32) update(v groph.VIdx, priority float32) <span class="cov8" title="1">{
        i := pq.v2i[v]
        pq.is[i].p = priority
        heap.Fix(pq, i)
}</span>

func (dij *Dijkstraf32) On(
        g groph.RGf32,
        start groph.VIdx,
        dist []float32,
        prev []groph.VIdx,
) ([]float32, []groph.VIdx) <span class="cov8" title="1">{
        vertexNo := g.VertexNo()
        dist = iutil.F32Slice(dist, vertexNo)
        if prev != nil </span><span class="cov8" title="1">{
                prev = iutil.VIdxSlice(prev, vertexNo)
        }</span>
        <span class="cov8" title="1">dij.init(vertexNo)
        dist[start] = 0
        for v := groph.V0; v &lt; g.VertexNo(); v++ </span><span class="cov8" title="1">{
                if v != start </span><span class="cov8" title="1">{
                        dist[v] = float32(math.Inf(1))
                }</span>
                <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                        prev[v] = -1
                }</span>
                <span class="cov8" title="1">heap.Push(dij, pqItemf32{v, dist[v]})</span>
        }
        <span class="cov8" title="1">for dij.Len() != 0 </span><span class="cov8" title="1">{
                u := heap.Pop(dij).(pqItemf32).v
                traverse.EachOutgoing(g, u, func(n groph.VIdx) </span><span class="cov8" title="1">{
                        alt := dist[u] + g.Edge(u, n) // TOOD EdgeD?
                        if alt &lt; dist[n] </span><span class="cov8" title="1">{
                                dist[n] = alt
                                if prev != nil </span><span class="cov8" title="1">{
                                        prev[n] = u
                                }</span>
                                <span class="cov8" title="1">dij.update(n, alt)</span>
                        }
                })
        }
        <span class="cov8" title="1">return dist, prev</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package shortestpath

import "git.fractalqb.de/fractalqb/groph"

func FloydWarshallf32(g groph.WGf32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        if u, ok := g.(groph.WUf32); ok </span><span class="cov8" title="1">{
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                        ds := u.Edge(i, k) + u.Edge(k, j)
                                        if u.EdgeU(i, j) &gt; ds </span><span class="cov8" title="1">{
                                                u.SetEdgeU(i, j, ds)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds := g.Edge(i, k) + g.Edge(k, j)
                                        if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        }
}

func FloydWarshalli32(g groph.WGi32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        if u, ok := g.(groph.WUi32); ok </span><span class="cov0" title="0">{
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov0" title="0">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov0" title="0">{
                                for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                        ds, ok := u.Edge(i, k)
                                        if !ok </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if tmp, ok := u.Edge(k, j); ok </span><span class="cov0" title="0">{
                                                ds += tmp
                                        }</span> else<span class="cov0" title="0"> {
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if d, ok := u.EdgeU(i, j); !ok || d &gt; ds </span><span class="cov0" title="0">{
                                                u.SetEdgeU(i, j, ds)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds, ok := g.Edge(i, k)
                                        if !ok </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tmp, ok := g.Edge(k, j); ok </span><span class="cov8" title="1">{
                                                ds += tmp
                                        }</span> else<span class="cov8" title="1"> {
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        }
}

func FloydWarshallAdjMxDf32(g *groph.AdjMxDf32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                ds := g.Edge(i, k) + g.Edge(k, j)
                                if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                        g.SetEdge(i, j, ds)
                                }</span>
                        }
                }
        }
}

func FloydWarshallAdjMxDi32(g *groph.AdjMxDi32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        for k := groph.V0; k &lt; vno; k++ </span><span class="cov8" title="1">{
                for i := groph.V0; i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := groph.V0; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                ds, ok := g.Edge(i, k)
                                if !ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if tmp, ok := g.Edge(k, j); ok </span><span class="cov8" title="1">{
                                        ds += tmp
                                }</span> else<span class="cov8" title="1"> {
                                        continue</span>
                                }
                                <span class="cov8" title="1">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov8" title="1">{
                                        g.SetEdge(i, j, ds)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package groph

type spmro map[VIdx]interface{}

type SpSoM struct {
        ws []spmro
}

func NewSpSoM(vertexNo VIdx, reuse *SpSoM) *SpSoM <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SpSoM{make([]spmro, vertexNo)}
        }</span>
        <span class="cov0" title="0">reuse.Reset(vertexNo)
        return reuse</span>
}

func (g *SpSoM) VertexNo() VIdx <span class="cov8" title="1">{ return len(g.ws) }</span>

func (g *SpSoM) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        row := g.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return row[v]</span>
}

func (g *SpSoM) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        row := g.ws[u]
        if w == nil </span><span class="cov8" title="1">{
                delete(row, v)
        }</span> else<span class="cov8" title="1"> {
                if row == nil </span><span class="cov8" title="1">{
                        row = make(spmro)
                        g.ws[u] = row
                }</span>
                <span class="cov8" title="1">row[v] = w</span>
        }
}

func (g *SpSoM) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        if g.ws == nil || cap(g.ws) &lt; vertexNo </span><span class="cov0" title="0">{
                g.ws = make([]spmro, vertexNo)
        }</span> else<span class="cov0" title="0"> {
                g.ws = g.ws[:vertexNo]
                for i := range g.ws </span><span class="cov0" title="0">{
                        g.ws[i] = nil
                }</span>
        }
}

func (g *SpSoM) EachOutgoing(from VIdx, onDest VisitVertex) <span class="cov0" title="0">{
        if row := g.ws[from]; row != nil </span><span class="cov0" title="0">{
                for n := range row </span><span class="cov0" title="0">{
                        onDest(n)
                }</span>
        }
}

func (g *SpSoM) OutDegree(v VIdx) int <span class="cov0" title="0">{
        row := g.ws[v]
        if row == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(row)</span>
}

type spmroi32 map[VIdx]int32

type SpSoMi32 struct {
        ws  []spmroi32
        Del int32
}

func NewSpSoMi32(vertexNo VIdx, reuse *SpSoMi32) *SpSoMi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SpSoMi32{
                        ws:  make([]spmroi32, vertexNo),
                        Del: i32cleared,
                }
        }</span>
        <span class="cov0" title="0">reuse.Reset(vertexNo)
        return reuse</span>
}

func (g *SpSoMi32) VertexNo() VIdx <span class="cov8" title="1">{ return len(g.ws) }</span>

func (m *SpSoMi32) Edge(u, v VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        row := m.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">if res, ok := row[v]; ok </span><span class="cov8" title="1">{
                return res, true
        }</span>
        <span class="cov8" title="1">return 0, false</span>
}

func (g *SpSoMi32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if res, ok := g.Edge(u, v); ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (g *SpSoMi32) SetEdge(u, v VIdx, w int32) <span class="cov8" title="1">{
        row := g.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                row = make(spmroi32)
                g.ws[u] = row
        }</span>
        <span class="cov8" title="1">row[v] = w</span>
}

func (g *SpSoMi32) DelEdge(u, v VIdx) <span class="cov8" title="1">{ delete(g.ws[u], v) }</span>

func (g *SpSoMi32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                g.DelEdge(u, v)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdge(u, v, w.(int32))
        }</span>
}

func (g *SpSoMi32) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        if g.ws == nil || cap(g.ws) &lt; vertexNo </span><span class="cov0" title="0">{
                g.ws = make([]spmroi32, vertexNo)
        }</span> else<span class="cov0" title="0"> {
                g.ws = g.ws[:vertexNo]
                for i := range g.ws </span><span class="cov0" title="0">{
                        g.ws[i] = nil
                }</span>
        }
}

func (g *SpSoMi32) EachOutgoing(from VIdx, onDest VisitVertex) <span class="cov0" title="0">{
        if row := g.ws[from]; row != nil </span><span class="cov0" title="0">{
                for n := range row </span><span class="cov0" title="0">{
                        onDest(n)
                }</span>
        }
}

func (g *SpSoMi32) OutDegree(v VIdx) int <span class="cov0" title="0">{
        row := g.ws[v]
        if row == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(row)</span>
}

type spmrof32 map[VIdx]float32

type SpSoMf32 struct {
        ws []spmrof32
}

func NewSpSoMf32(vertexNo VIdx, reuse *SpSoMf32) *SpSoMf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SpSoMf32{make([]spmrof32, vertexNo)}
        }</span>
        <span class="cov0" title="0">reuse.Reset(vertexNo)
        return reuse</span>
}

func (g *SpSoMf32) VertexNo() VIdx <span class="cov8" title="1">{ return len(g.ws) }</span>

func (m *SpSoMf32) Edge(u, v VIdx) (w float32) <span class="cov8" title="1">{
        row := m.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                return NaN32()
        }</span>
        <span class="cov8" title="1">if res, ok := row[v]; ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return NaN32()</span>
}

func (g *SpSoMf32) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if res := g.Edge(u, v); IsNaN32(res) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return res
        }</span>
}

func (g *SpSoMf32) SetEdge(u, v VIdx, w float32) <span class="cov8" title="1">{
        row := g.ws[u]
        if row == nil </span><span class="cov8" title="1">{
                row = make(spmrof32)
                g.ws[u] = row
        }</span>
        <span class="cov8" title="1">row[v] = w</span>
}

func (g *SpSoMf32) DelEdge(u, v VIdx) <span class="cov8" title="1">{ delete(g.ws[u], v) }</span>

func (g *SpSoMf32) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                g.DelEdge(u, v)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdge(u, v, w.(float32))
        }</span>
}

func (g *SpSoMf32) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        if g.ws == nil || cap(g.ws) &lt; vertexNo </span><span class="cov0" title="0">{
                g.ws = make([]spmrof32, vertexNo)
        }</span> else<span class="cov0" title="0"> {
                g.ws = g.ws[:vertexNo]
                for i := range g.ws </span><span class="cov0" title="0">{
                        g.ws[i] = nil
                }</span>
        }
}

func (g *SpSoMf32) EachOutgoing(from VIdx, onDest VisitVertex) <span class="cov0" title="0">{
        if row := g.ws[from]; row != nil </span><span class="cov0" title="0">{
                for n := range row </span><span class="cov0" title="0">{
                        onDest(n)
                }</span>
        }
}

func (g *SpSoMf32) OutDegree(v VIdx) int <span class="cov0" title="0">{
        row := g.ws[v]
        if row == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(row)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package groph

type RSubgraph struct {
        G   RGraph
        VMap []VIdx
}

func (g RSubgraph) VertexNo() VIdx <span class="cov0" title="0">{
        return VIdx(len(g.VMap))
}</span>

func (g RSubgraph) Weight(u, v VIdx) interface{} <span class="cov0" title="0">{
        return g.Weight(g.VMap[u], g.VMap[v])
}</span>

type WSubgraph struct {
        G   WGraph
        VMap []VIdx
}

func (g WSubgraph) VertexNo() VIdx <span class="cov0" title="0">{
        return VIdx(len(g.VMap))
}</span>

func (g WSubgraph) Weight(u, v VIdx) interface{} <span class="cov0" title="0">{
        return g.Weight(g.VMap[u], g.VMap[v])
}</span>

func (g WSubgraph) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        panic("must not clear WSubgraph")</span>
}

func (g WSubgraph) SetWeight(u, v VIdx, w interface{}) <span class="cov0" title="0">{
        g.SetWeight(g.VMap[u], g.VMap[v], w)
}</span>

// TODO Must sort vls to handle WeightU and SetWeightU
// type RSubUndir struct {
//         g   RUndirected
//         vls []VIdx
// }

// func (g RSubUndir) VertexNo() VIdx {
//         return VIdx(len(g.vls))
// }

// func (g RSubUndir) Weight(u, v VIdx) interface{} {
//         return g.Weight(g.vls[u], g.vls[v])
// }

// func (g RSubUndir) WeightU(u, v VIdx) interface{} {
//         return g.WeightU(g.vls[u], g.vls[v])
// }

// type WSubUndir struct {
//         g   WGraph
//         vls []VIdx
// }

// func (g WSubUndir) VertexNo() VIdx {
//         return VIdx(len(g.vls))
// }

// func (g WSubUndir) Weight(u, v VIdx) interface{} {
//         return g.Weight(g.vls[u], g.vls[v])
// }

// func (g WSubUndir) WeightU(u, v VIdx) interface{} {
//         return g.WeightU(g.vls[u], g.vls[v])
// }

// func (g WSubUndir) Reset(vertexNo VIdx) {
//         panic("must not clear WSubgraph")
// }

// func (g WSubUndir) SetWeight(u, v VIdx, w interface{}) {
//         g.SetWeight(g.vls[u], g.vls[v], w)
// }

// func (g WSubUndir) SetWeightU(u, v VIdx, w interface{}) {
//         g.SetWeight(g.vls[u], g.vls[v], w)
// }
</pre>
		
		<pre class="file" id="file11" style="display: none">package tsp

import "git.fractalqb.de/fractalqb/groph"

// d2optU computes the difference in weight sum for a specific 2-opt operation
// that swaps e0 / e1 for undirected graphs.
func diff2optU(g groph.RGf32, p []groph.VIdx, e0, e1 groph.VIdx) (wdiff float32) <span class="cov8" title="1">{
        lenp := groph.VIdx(len(p))
        wdiff = -g.Edge(p[e0], p[e0+1])
        wdiff += g.Edge(p[e0], p[e1])
        if e1+1 == lenp </span><span class="cov8" title="1">{
                wdiff -= g.Edge(p[e1], p[0])
                wdiff += g.Edge(p[e0+1], p[0])
        }</span> else<span class="cov8" title="1"> {
                wdiff -= g.Edge(p[e1], p[e1+1])
                wdiff += g.Edge(p[e0+1], p[e1+1])
        }</span>
        <span class="cov8" title="1">return wdiff</span>
}

// d2optD computes the difference in weight sum for a specific 2-opt operation
// that swaps e0 / e1 for directed graphs.
func diff2optD(g groph.RGf32, p []groph.VIdx, e0, e1 groph.VIdx) (wdiff float32) <span class="cov8" title="1">{
        wdiff = diff2optU(g, p, e0, e1)
        for i := e0 + 1; i &lt; e1; i++ </span><span class="cov8" title="1">{
                wdiff -= g.Edge(p[i], p[i+1])
                wdiff += g.Edge(p[i+1], p[i])
        }</span>
        <span class="cov8" title="1">return wdiff</span>
}

func apply2opt(p []groph.VIdx, e0, e1 groph.VIdx) <span class="cov8" title="1">{
        e0++
        for e0 &lt; e1 </span><span class="cov8" title="1">{
                p[e0], p[e1] = p[e1], p[e0]
                e0++
                e1--
        }</span>
}

func TwoOptf32(g groph.RGf32) (path []groph.VIdx, plen float32) <span class="cov8" title="1">{
        var diff2opt func(groph.RGf32, []groph.VIdx, groph.VIdx, groph.VIdx) float32
        if groph.Directed(g) </span><span class="cov8" title="1">{
                diff2opt = diff2optD
        }</span> else<span class="cov8" title="1"> {
                diff2opt = diff2optU
        }</span>
        <span class="cov8" title="1">vno := g.VertexNo()
        path = make([]groph.VIdx, vno)
        for i := groph.V0; i+1 &lt; vno; i++ </span><span class="cov8" title="1">{
                path[i] = i
                plen += g.Edge(i, i+1)
        }</span>
        <span class="cov8" title="1">path[vno-1] = vno - 1
        plen += g.Edge(vno-1, 0)
        for </span><span class="cov8" title="1">{
                be0, be1 := vno, vno
                bdiff := float32(0)
                for e0 := groph.V0; e0 &lt; vno; e0++ </span><span class="cov8" title="1">{
                        for e1 := e0 + 1; e1 &lt; vno; e1++ </span><span class="cov8" title="1">{
                                diff := diff2opt(g, path, e0, e1)
                                if diff &lt; bdiff </span><span class="cov8" title="1">{
                                        be0, be1 = e0, e1
                                        bdiff = diff
                                }</span>
                        }
                }
                <span class="cov8" title="1">if bdiff &lt; float32(0) </span><span class="cov8" title="1">{
                        apply2opt(path, be0, be1)
                        plen += bdiff
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
        <span class="cov8" title="1">return path, plen</span>
}

// Benchmark showed that the proformance gain is not worth it
// func (g *AdjMxDf32) Tsp2Opt() (path []uint, plen float32) {
//         vno := g.VertexNo()
//         path = make([]uint, vno)
//         for i := uint(0); i+1 &lt; vno; i++ {
//                 path[i] = i
//                 plen += g.Edge(i, i+1)
//         }
//         path[vno-1] = vno - 1
//         plen += g.Edge(vno-1, 0)
//         for {
//                 be0, be1 := vno, vno
//                 bdiff := float32(0)
//                 for e0 := uint(0); e0 &lt; vno; e0++ {
//                         for e1 := e0 + 1; e1 &lt; vno; e1++ {
//                                 diff := diff2optD(g, path, e0, e1)
//                                 if diff &lt; bdiff {
//                                         be0, be1 = e0, e1
//                                         bdiff = diff
//                                 }
//                         }
//                 }
//                 if bdiff &lt; float32(0) {
//                         apply2opt(path, be0, be1)
//                         plen += bdiff
//                 } else {
//                         break
//                 }
//         }
//         return path, plen
// }

// Benchmark showed that the proformance gain is not worth it
// func (g *AdjMxUf32) Tsp2Opt() (path []uint, plen float32) {
//         vno := g.VertexNo()
//         path = make([]uint, vno)
//         for i := uint(0); i+1 &lt; vno; i++ {
//                 path[i] = i
//                 plen += g.Edge(i, i+1)
//         }
//         path[vno-1] = vno - 1
//         plen += g.Edge(vno-1, 0)
//         for {
//                 be0, be1 := vno, vno
//                 bdiff := float32(0)
//                 for e0 := uint(0); e0 &lt; vno; e0++ {
//                         for e1 := e0 + 1; e1 &lt; vno; e1++ {
//                                 diff := diff2optU(g, path, e0, e1)
//                                 if diff &lt; bdiff {
//                                         be0, be1 = e0, e1
//                                         bdiff = diff
//                                 }
//                         }
//                 }
//                 if bdiff &lt; float32(0) {
//                         apply2opt(path, be0, be1)
//                         plen += bdiff
//                 } else {
//                         break
//                 }
//         }
//         return path, plen
// }
</pre>
		
		<pre class="file" id="file12" style="display: none">package tsp

import "git.fractalqb.de/fractalqb/groph"

func Greedyf32(m groph.RGf32) (path []groph.VIdx, plen float32) <span class="cov0" title="0">{
        size := m.VertexNo()
        switch size </span>{
        case 0:<span class="cov0" title="0">
                return nil, 0</span>
        case 1:<span class="cov0" title="0">
                return []groph.VIdx{0}, 0</span>
        }
        <span class="cov0" title="0">L := size - 1
        path = make([]groph.VIdx, size)
        // start with L → 0 → 1 → … → L
        path[L] = L
        best := m.Edge(L, 0)
        for k := groph.V0; k &lt; L; k++ </span><span class="cov0" title="0">{
                path[k] = k
                best += m.Edge(k, k+1)
        }</span>
        <span class="cov0" title="0">perm := make([]groph.VIdx, L)
        copy(perm, path)
        c := make([]groph.VIdx, L) // automatic set to 0 (go!)
        i := groph.V0
        for i &lt; L </span><span class="cov0" title="0">{
                if c[i] &lt; i </span><span class="cov0" title="0">{
                        if (i &amp; 1) == 0 </span><span class="cov0" title="0">{
                                perm[0], perm[i] = perm[i], perm[0]
                        }</span> else<span class="cov0" title="0"> {
                                perm[c[i]], perm[i] = perm[i], perm[c[i]]
                        }</span>
                        <span class="cov0" title="0">curl := m.Edge(L, perm[0])
                        curl += m.Edge(perm[L-1], L)
                        for i := groph.V0; i+1 &lt; L; i++ </span><span class="cov0" title="0">{
                                curl += m.Edge(perm[i], perm[i+1])
                        }</span>
                        <span class="cov0" title="0">if curl &lt; best </span><span class="cov0" title="0">{
                                copy(path[:L], perm)
                                best = curl
                        }</span>
                        <span class="cov0" title="0">c[i]++
                        i = 0</span>
                } else<span class="cov0" title="0"> {
                        c[i] = 0
                        i++
                }</span>
        }
        <span class="cov0" title="0">return path, best</span>
}

func GreedyAdjMxDf32(m *groph.AdjMxDf32) (path []groph.VIdx, plen float32) <span class="cov8" title="1">{
        size := m.VertexNo()
        switch size </span>{
        case 0:<span class="cov0" title="0">
                return nil, 0</span>
        case 1:<span class="cov0" title="0">
                return []groph.VIdx{0}, 0</span>
        }
        <span class="cov8" title="1">L := size - 1
        path = make([]groph.VIdx, size)
        // start with L → 0 → 1 → … → L
        path[L] = L
        best := m.Edge(L, 0)
        for k := groph.V0; k &lt; L; k++ </span><span class="cov8" title="1">{
                path[k] = k
                best += m.Edge(k, k+1)
        }</span>
        <span class="cov8" title="1">perm := make([]groph.VIdx, L)
        copy(perm, path)
        c := make([]groph.VIdx, L) // automatic set to 0 (go!)
        i := groph.V0
        for i &lt; L </span><span class="cov8" title="1">{
                if c[i] &lt; i </span><span class="cov8" title="1">{
                        if (i &amp; 1) == 0 </span><span class="cov8" title="1">{
                                perm[0], perm[i] = perm[i], perm[0]
                        }</span> else<span class="cov8" title="1"> {
                                perm[c[i]], perm[i] = perm[i], perm[c[i]]
                        }</span>
                        <span class="cov8" title="1">curl := m.Edge(L, perm[0])
                        curl += m.Edge(perm[L-1], L)
                        for i := groph.V0; i+1 &lt; L; i++ </span><span class="cov8" title="1">{
                                curl += m.Edge(perm[i], perm[i+1])
                        }</span>
                        <span class="cov8" title="1">if curl &lt; best </span><span class="cov8" title="1">{
                                copy(path[:L], perm)
                                best = curl
                        }</span>
                        <span class="cov8" title="1">c[i]++
                        i = 0</span>
                } else<span class="cov8" title="1"> {
                        c[i] = 0
                        i++
                }</span>
        }
        <span class="cov8" title="1">return path, best</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package groph

type RUadapt struct {
        G RGraph
}

func AsRUndir(g RGraph) RUndirected <span class="cov0" title="0">{
        if u, ok := g.(RUndirected); ok </span><span class="cov0" title="0">{
                return u
        }</span>
        <span class="cov0" title="0">return RUadapt{g}</span>
}

func (g RUadapt) VertexNo() VIdx <span class="cov0" title="0">{ return g.G.VertexNo() }</span>

func (g RUadapt) Weight(u, v VIdx) interface{} <span class="cov0" title="0">{
        if u &gt; v </span><span class="cov0" title="0">{
                return g.G.Weight(u, v)
        }</span>
        <span class="cov0" title="0">return g.G.Weight(v, u)</span>
}

func (g RUadapt) WeightU(u, v VIdx) interface{} <span class="cov0" title="0">{ return g.G.Weight(u, v) }</span>

type WUadapt struct {
        G WGraph
}

func AsWUndir(g WGraph) WUndirected <span class="cov8" title="1">{
        if u, ok := g.(WUndirected); ok </span><span class="cov0" title="0">{
                return u
        }</span>
        <span class="cov8" title="1">return WUadapt{g}</span>
}

func (g WUadapt) VertexNo() VIdx <span class="cov8" title="1">{ return g.G.VertexNo() }</span>

func (g WUadapt) Weight(u, v VIdx) interface{} <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                return g.G.Weight(u, v)
        }</span>
        <span class="cov8" title="1">return g.G.Weight(v, u)</span>
}

func (g WUadapt) WeightU(u, v VIdx) interface{} <span class="cov8" title="1">{ return g.G.Weight(u, v) }</span>

func (g WUadapt) Reset(vertexNo VIdx) <span class="cov0" title="0">{
        g.G.Reset(vertexNo)
}</span>

func (g WUadapt) SetWeight(u, v VIdx, w interface{}) <span class="cov8" title="1">{
        if u &gt; v </span><span class="cov8" title="1">{
                g.G.SetWeight(u, v, w)
        }</span>
        <span class="cov8" title="1">g.G.SetWeight(v, u, w)</span>
}

func (g WUadapt) SetWeightU(u, v VIdx, w interface{}) <span class="cov8" title="1">{ g.G.SetWeight(u, v, w) }</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package util

import (
        "errors"
        "fmt"

        "git.fractalqb.de/fractalqb/groph"
)

type CpClipped int

func (cc CpClipped) Error() string <span class="cov0" title="0">{
        if cc &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d vertices ignored from source", -cc)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d vertices not covered in destination", cc)</span>
}

func MustCp(g groph.WGraph, err error) groph.WGraph <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

// CpWeights copies the edge weights from one graph to another.
// Vertices are identified by their index, i.e. the user has to take care of
// the vertex order. If the number of vertices in the graph differs the smaller
// graph determines how many edge weights are copied.
func CpWeights(dst groph.WGraph, src groph.RGraph) (groph.WGraph, error) <span class="cov8" title="1">{
        sz := dst.VertexNo()
        if src.VertexNo() &lt; sz </span><span class="cov0" title="0">{
                sz = src.VertexNo()
        }</span>
        <span class="cov8" title="1">if udst, ok := dst.(groph.WUndirected); ok </span><span class="cov8" title="1">{
                if usrc, ok := src.(groph.RUndirected); ok </span><span class="cov8" title="1">{
                        for i := groph.V0; i &lt; sz; i++ </span><span class="cov8" title="1">{
                                udst.SetWeightU(i, i, usrc.WeightU(i, i))
                                for j := groph.V0; j &lt; i; j++ </span><span class="cov8" title="1">{
                                        udst.SetWeightU(i, j, usrc.WeightU(i, j))
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        return dst, errors.New("cannot copy from directed to undirected graph")
                }</span>
        } else<span class="cov0" title="0"> if usrc, ok := src.(groph.RUndirected); ok </span><span class="cov0" title="0">{
                for i := groph.V0; i &lt; sz; i++ </span><span class="cov0" title="0">{
                        dst.SetWeight(i, i, usrc.WeightU(i, i))
                        for j := groph.V0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                w := usrc.WeightU(i, j)
                                dst.SetWeight(i, j, w)
                                dst.SetWeight(j, i, w)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for i := groph.V0; i &lt; sz; i++ </span><span class="cov0" title="0">{
                        for j := groph.V0; j &lt; sz; j++ </span><span class="cov0" title="0">{
                                dst.SetWeight(i, j, src.Weight(i, j))
                        }</span>
                }
        }
        <span class="cov8" title="1">vnd := dst.VertexNo() - src.VertexNo()
        if vnd == 0 </span><span class="cov8" title="1">{
                return dst, nil
        }</span>
        <span class="cov0" title="0">return dst, CpClipped(vnd)</span>
}

// CpXWeights “transfers” the edge weights from src Graph to dst Graph
// with the same vertex restirctions as CpWeights. CpXWeights applies
// the transformation function xf() to each edge weight.
func CpXWeights(
        dst groph.WGraph,
        src groph.RGraph,
        xf func(in interface{}) interface{},
) (groph.WGraph, error) <span class="cov0" title="0">{
        sz := dst.VertexNo()
        if src.VertexNo() &lt; sz </span><span class="cov0" title="0">{
                sz = src.VertexNo()
        }</span>
        <span class="cov0" title="0">var w interface{}
        if udst, ok := dst.(groph.WUndirected); ok </span><span class="cov0" title="0">{
                if usrc, ok := src.(groph.RUndirected); ok </span><span class="cov0" title="0">{
                        for i := groph.V0; i &lt; sz; i++ </span><span class="cov0" title="0">{
                                w = usrc.WeightU(i, i)
                                udst.SetWeightU(i, i, xf(w))
                                for j := groph.V0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                        w = usrc.WeightU(i, j)
                                        udst.SetWeightU(i, j, xf(w))
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        return dst, errors.New("cannot copy from directed to undirected graph")
                }</span>
        } else<span class="cov0" title="0"> if usrc, ok := src.(groph.RUndirected); ok </span><span class="cov0" title="0">{
                for i := groph.V0; i &lt; sz; i++ </span><span class="cov0" title="0">{
                        w = usrc.WeightU(i, i)
                        dst.SetWeight(i, i, xf(w))
                        for j := groph.V0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                w := xf(usrc.WeightU(i, j))
                                dst.SetWeight(i, j, w)
                                dst.SetWeight(j, i, w)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for i := groph.V0; i &lt; sz; i++ </span><span class="cov0" title="0">{
                        for j := groph.V0; j &lt; sz; j++ </span><span class="cov0" title="0">{
                                w = src.Weight(i, j)
                                dst.SetWeight(i, j, xf(w))
                        }</span>
                }
        }
        <span class="cov0" title="0">vnd := dst.VertexNo() - src.VertexNo()
        if vnd == 0 </span><span class="cov0" title="0">{
                return dst, nil
        }</span>
        <span class="cov0" title="0">return dst, CpClipped(vnd)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package util

import (
        "fmt"

        "git.fractalqb.de/fractalqb/groph"
)

type MergeError struct {
        u, v groph.VIdx
        err  error
}

func (e MergeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("edges %d, %d: %s", e.u, e.v, e.err)
}</span>

func (e MergeError) Unwrap() error <span class="cov0" title="0">{ return e.err }</span>

type RUadapter struct {
        G     groph.RGraph
        Merge func(u, v groph.VIdx) (merged interface{}, err error)
        Err   error
}

func (rua *RUadapter) VertexNo() groph.VIdx <span class="cov8" title="1">{ return rua.G.VertexNo() }</span>

func (rua *RUadapter) Weight(u, v groph.VIdx) interface{} <span class="cov0" title="0">{
        return rua.WeightU(u, v)
}</span>

func (rua *RUadapter) WeightU(u, v groph.VIdx) (res interface{}) <span class="cov8" title="1">{
        var err error
        if res, err = rua.Merge(u, v); err != nil </span><span class="cov8" title="1">{
                rua.Err = MergeError{u, v, err}
        }</span>
        <span class="cov8" title="1">return res</span>
}

func MergeWeights(
        g groph.RGraph,
        merge func(w1, w2 interface{}) (merged interface{}, err error),
) func(u, v groph.VIdx) (interface{}, error) <span class="cov8" title="1">{
        return func(u, v groph.VIdx) (interface{}, error) </span><span class="cov8" title="1">{
                w1 := g.Weight(u, v)
                w2 := g.Weight(v, u)
                return merge(w1, w2)
        }</span>
}

func MergeEqual(w1, w2 interface{}) (interface{}, error) <span class="cov8" title="1">{
        if w1 == w2 </span><span class="cov8" title="1">{
                return w1, nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("not equal: '%v' / '%v'", w1, w2)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
