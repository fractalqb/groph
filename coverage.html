
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">git.fractalqb.de/fractalqb/groph/adapt.go (12.7%)</option>
				
				<option value="file1">git.fractalqb.de/fractalqb/groph/adjmatrix.go (42.3%)</option>
				
				<option value="file2">git.fractalqb.de/fractalqb/groph/bitset.go (100.0%)</option>
				
				<option value="file3">git.fractalqb.de/fractalqb/groph/graph.go (13.3%)</option>
				
				<option value="file4">git.fractalqb.de/fractalqb/groph/internal/test/d2graph.go (0.0%)</option>
				
				<option value="file5">git.fractalqb.de/fractalqb/groph/internal/util/slices.go (20.0%)</option>
				
				<option value="file6">git.fractalqb.de/fractalqb/groph/mst/kruskal.go (81.8%)</option>
				
				<option value="file7">git.fractalqb.de/fractalqb/groph/sp/dijkstra.go (98.9%)</option>
				
				<option value="file8">git.fractalqb.de/fractalqb/groph/sp/floyd_warshall.go (80.7%)</option>
				
				<option value="file9">git.fractalqb.de/fractalqb/groph/sparse.go (67.5%)</option>
				
				<option value="file10">git.fractalqb.de/fractalqb/groph/tsp/2opt.go (100.0%)</option>
				
				<option value="file11">git.fractalqb.de/fractalqb/groph/tsp/greedy.go (46.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package groph

import (
        "fmt"
        "math"
        "reflect"
)

type Slice struct {
        slc reflect.Value
        dir bool
        sz  VIdx
}

func NewSlice(directed bool, edgeSlice interface{}) *Slice <span class="cov0" title="0">{
        res := &amp;Slice{
                slc: reflect.ValueOf(edgeSlice),
                dir: directed,
        }
        if directed </span><span class="cov0" title="0">{
                res.sz = VIdx(math.Sqrt(float64(res.slc.Len())))
        }</span> else<span class="cov0" title="0"> {
                res.sz = VIdx(nSumRev(VIdx(res.slc.Len())))
        }</span>
        <span class="cov0" title="0">return res</span>
}

func (g *Slice) Check() (*Slice, error) <span class="cov0" title="0">{
        if g.slc.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return g, fmt.Errorf("edges have to be a slice, got %s",
                        g.slc.Type().String())
        }</span>
        <span class="cov0" title="0">if g.dir </span><span class="cov0" title="0">{
                if g.sz*g.sz != VIdx(g.slc.Len()) </span><span class="cov0" title="0">{
                        return g, fmt.Errorf("slice len is not quadratic")
                }</span>
        } else<span class="cov0" title="0"> if nSum(g.sz) != VIdx(g.slc.Len()) </span><span class="cov0" title="0">{
                return g, fmt.Errorf("slice len is not Sum(1, ..., n)")
        }</span>
        <span class="cov0" title="0">return g, nil</span>
}

func (g *Slice) Must() *Slice <span class="cov0" title="0">{
        var err error
        g, err = g.Check()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

func (g *Slice) VertexNo() VIdx <span class="cov0" title="0">{ return g.sz }</span>

func (g *Slice) Directed() bool <span class="cov0" title="0">{ return g.dir }</span>

func (g *Slice) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov0" title="0">{
        if g.dir </span><span class="cov0" title="0">{
                return g.slc.Index(int(g.sz*edgeFrom + edgeTo)).Interface()
        }</span> else<span class="cov0" title="0"> if edgeFrom &lt; edgeTo </span><span class="cov0" title="0">{
                return g.slc.Index(int(uIdx(g.sz, edgeFrom, edgeTo))).Interface()
        }</span>
        <span class="cov0" title="0">return g.slc.Index(int(uIdx(g.sz, edgeTo, edgeFrom))).Interface()</span>
}

// SliceNMeasure implements a metric RGraph based on a slice of vertices of
// some type V and a function f(u V, v V) → W that computes the weight of type
// W for any edge (u, v).
//
// From this use e.g. CpWeights or CpXWeights to initialize an other WGraph.
type SliceNMeasure struct {
        slc reflect.Value
        m   reflect.Value
        dir bool
}

func NewSliceNMeasure(
        vertexSlice interface{},
        measure interface{},
        directed bool) *SliceNMeasure <span class="cov8" title="1">{
        res := &amp;SliceNMeasure{
                slc: reflect.ValueOf(vertexSlice),
                m:   reflect.ValueOf(measure),
                dir: directed,
        }
        return res
}</span>

// Check does type checking on g. It always returns g. Only if everything is OK
// the returned error is nil.
func (g *SliceNMeasure) Check() (*SliceNMeasure, error) <span class="cov0" title="0">{
        if g.slc.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return g, fmt.Errorf("vertex set has to be a slice, got %s",
                        g.slc.Type().String())
        }</span>
        <span class="cov0" title="0">if g.m.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return g, fmt.Errorf("edge weight measure must be a function, got: %s",
                        g.m.Type().String())
        }</span> // TODO more precise checking
        <span class="cov0" title="0">return g, nil</span>
}

// Verify call Check on g and panics if Check returns an error.
func (g *SliceNMeasure) Must() *SliceNMeasure <span class="cov0" title="0">{
        if _, err := g.Check(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return g</span>
}

func (g *SliceNMeasure) VertexNo() VIdx <span class="cov8" title="1">{
        return VIdx(g.slc.Len())
}</span>

func (g *SliceNMeasure) Vertex(idx VIdx) interface{} <span class="cov8" title="1">{
        return g.slc.Index(int(idx)).Interface()
}</span>

func (g *SliceNMeasure) Directed() bool <span class="cov0" title="0">{
        return g.dir
}</span>

func (g *SliceNMeasure) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov8" title="1">{
        f, t := g.slc.Index(int(edgeFrom)), g.slc.Index(int(edgeTo))
        d := g.m.Call([]reflect.Value{f, t})
        return d[0].Interface()
}</span>

type RSubgraph struct {
        g   RGraph
        vls []VIdx
}

var _ RGraph = (*RSubgraph)(nil)

func (g *RSubgraph) VertexNo() VIdx <span class="cov0" title="0">{
        return VIdx(len(g.vls))
}</span>

func (g *RSubgraph) Directed() bool <span class="cov0" title="0">{
        return g.g.Directed()
}</span>

func (g *RSubgraph) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov0" title="0">{
        edgeFrom = g.vls[edgeFrom]
        edgeTo = g.vls[edgeTo]
        return g.Weight(edgeFrom, edgeTo)
}</span>

type WSubgraph struct {
        g   WGraph
        vls []VIdx
}

var _ WGraph = (*WSubgraph)(nil)

func (g *WSubgraph) VertexNo() VIdx <span class="cov0" title="0">{
        return VIdx(len(g.vls))
}</span>

func (g *WSubgraph) Directed() bool <span class="cov0" title="0">{
        return g.g.Directed()
}</span>

func (g *WSubgraph) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov0" title="0">{
        edgeFrom = g.vls[edgeFrom]
        edgeTo = g.vls[edgeTo]
        return g.Weight(edgeFrom, edgeTo)
}</span>

func (g *WSubgraph) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        panic("must not clear WSubgraph")</span>
}

func (g *WSubgraph) SetWeight(edgeFrom, edgeTo VIdx, w interface{}) <span class="cov0" title="0">{
        edgeFrom = g.vls[edgeFrom]
        edgeTo = g.vls[edgeTo]
        g.SetWeight(edgeFrom, edgeTo, w)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package groph

import (
        "math"

        "git.fractalqb.de/fractalqb/groph/internal/util"
)

type adjMx struct {
        sz VIdx
}

func (m *adjMx) VertexNo() VIdx <span class="cov8" title="1">{ return m.sz }</span>

// AdjMxDbitmap is a directed WGraph with boolean edge weights implemented as
// bitmap. This sacrifices runtime performance for lesser memory usage.
type AdjMxDbitmap struct {
        adjMx
        bs []uint
}

func NewAdjMxDbitmap(vertexNo VIdx, reuse *AdjMxDbitmap) *AdjMxDbitmap <span class="cov8" title="1">{
        sz := uint(vertexNo * vertexNo)
        sz = (sz + (wordBits - 1)) / wordBits
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDbitmap{
                        adjMx: adjMx{sz: vertexNo},
                        bs:    make([]uint, sz),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.bs = util.UIntSlice(reuse.bs, int(sz))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDbitmap) Init(flag bool) *AdjMxDbitmap <span class="cov0" title="0">{
        if flag </span><span class="cov0" title="0">{
                for i := range m.bs </span><span class="cov0" title="0">{
                        m.bs[i] = ^uint(0)
                }</span>
        } else<span class="cov0" title="0"> {
                for i := range m.bs </span><span class="cov0" title="0">{
                        m.bs[i] = 0
                }</span>
        }
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDbitmap) Directed() bool <span class="cov8" title="1">{ return true }</span>

func (m *AdjMxDbitmap) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxDbitmap(vertexNo, m)
        m.Init(false)
}</span>

func (m *AdjMxDbitmap) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov0" title="0">{
        return m.Edge(edgeFrom, edgeTo)
}</span>

func (m *AdjMxDbitmap) SetWeight(i, j VIdx, w interface{}) <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                m.SetEdge(i, j, false)
        }</span> else<span class="cov0" title="0"> {
                m.SetEdge(i, j, w.(bool))
        }</span>
}

func (m *AdjMxDbitmap) Edge(i, j VIdx) (w bool) <span class="cov8" title="1">{
        w = BitSetGet(m.bs, uint(m.sz*i+j))
        return w
}</span>

func (m *AdjMxDbitmap) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        if w </span><span class="cov8" title="1">{
                BitSetSet(m.bs, uint(m.sz*i+j))
        }</span> else<span class="cov8" title="1"> {
                BitSetUnset(m.bs, uint(m.sz*i+j))
        }</span>
}

type AdjMxDbool struct {
        adjMx
        bs []bool
}

func NewAdjMxDbool(vertexNo VIdx, reuse *AdjMxDbool) *AdjMxDbool <span class="cov8" title="1">{
        sz := vertexNo * vertexNo
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDbool{
                        adjMx: adjMx{sz: vertexNo},
                        bs:    make([]bool, sz),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.bs = util.BoolSlice(reuse.bs, int(sz))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDbool) Init(flag bool) *AdjMxDbool <span class="cov0" title="0">{
        for i := range m.bs </span><span class="cov0" title="0">{
                m.bs[i] = flag
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDbool) Directed() bool <span class="cov8" title="1">{ return true }</span>

func (m *AdjMxDbool) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxDbool(vertexNo, m)
        m.Init(false)
}</span>

func (m *AdjMxDbool) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov0" title="0">{
        return m.Edge(edgeFrom, edgeTo)
}</span>

func (m *AdjMxDbool) SetWeight(i, j VIdx, w interface{}) <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                m.SetEdge(i, j, false)
        }</span> else<span class="cov0" title="0"> {
                m.SetEdge(i, j, w.(bool))
        }</span>
}

func (m *AdjMxDbool) Edge(i, j VIdx) (w bool) <span class="cov8" title="1">{
        return m.bs[m.sz*i+j]
}</span>

func (m *AdjMxDbool) SetEdge(i, j VIdx, w bool) <span class="cov8" title="1">{
        m.bs[m.sz*i+j] = w
}</span>

type AdjMxDi32 struct {
        adjMx
        w       []int32
        Cleared int32
}

const i32cleared = -2147483648 // min{ int32 }

func NewAdjMxDi32(vertexNo VIdx, reuse *AdjMxDi32) *AdjMxDi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDi32{
                        adjMx:   adjMx{sz: vertexNo},
                        w:       make([]int32, vertexNo*vertexNo),
                        Cleared: i32cleared,
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = util.I32Slice(reuse.w, int(vertexNo*vertexNo))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDi32) Init(w int32) *AdjMxDi32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDi32) Directed() bool <span class="cov8" title="1">{ return true }</span>

func (m *AdjMxDi32) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        c := m.Cleared
        NewAdjMxDi32(vertexNo, m)
        m.Cleared = c
        m.Init(m.Cleared)
}</span>

func (m *AdjMxDi32) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov8" title="1">{
        res, ok := m.Edge(edgeFrom, edgeTo)
        if ok </span><span class="cov8" title="1">{
                return res
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *AdjMxDi32) SetWeight(i, j VIdx, w interface{}) <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                m.DelEdge(i, j)
        }</span> else<span class="cov0" title="0"> {
                m.w[m.sz*i+j] = w.(int32)
        }</span>
}

func (m *AdjMxDi32) Edge(i, j VIdx) (w int32, exists bool) <span class="cov8" title="1">{
        w = m.w[m.sz*i+j]
        return w, w != m.Cleared
}</span>

func (m *AdjMxDi32) SetEdge(i, j VIdx, w int32) <span class="cov8" title="1">{
        m.w[m.sz*i+j] = w
}</span>

func (m *AdjMxDi32) DelEdge(i, j VIdx) <span class="cov0" title="0">{
        m.SetEdge(i, j, m.Cleared)
}</span>

type AdjMxDf32 struct {
        adjMx
        w []float32
}

func NewAdjMxDf32(vertexNo VIdx, reuse *AdjMxDf32) *AdjMxDf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxDf32{
                        adjMx: adjMx{sz: vertexNo},
                        w:     make([]float32, vertexNo*vertexNo),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = util.F32Slice(reuse.w, int(vertexNo*vertexNo))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxDf32) Init(w float32) *AdjMxDf32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxDf32) Directed() bool <span class="cov8" title="1">{ return true }</span>

func (m *AdjMxDf32) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxDf32(vertexNo, m)
        m.Init(nan32)
}</span>

func (m *AdjMxDf32) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov0" title="0">{
        w := m.Edge(edgeFrom, edgeTo)
        if math.IsNaN(float64(w)) </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return w
        }</span>
}

func (m *AdjMxDf32) SetWeight(i, j VIdx, w interface{}) <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                m.w[m.sz*i+j] = nan32
        }</span> else<span class="cov0" title="0"> {
                m.w[m.sz*i+j] = w.(float32)
        }</span>
}

func (m *AdjMxDf32) Edge(i, j VIdx) (w float32) <span class="cov8" title="1">{
        return m.w[m.sz*i+j]
}</span>

func (m *AdjMxDf32) SetEdge(i, j VIdx, w float32) <span class="cov8" title="1">{
        m.w[m.sz*i+j] = w
}</span>

// uSum computes the sum of the n 1st integers, i.e. 1+2+3+…+n
func nSum(n VIdx) VIdx <span class="cov8" title="1">{ return n * (n + 1) / 2 }</span>

func nSumRev(n VIdx) float64 <span class="cov0" title="0">{
        r := math.Sqrt(0.25 + 2*float64(n))
        return r - 0.5
}</span>

type AdjMxUf32 struct {
        adjMx
        w []float32
}

func NewAdjMxUf32(vertexNo VIdx, reuse *AdjMxUf32) *AdjMxUf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUf32{
                        adjMx: adjMx{sz: vertexNo},
                        w:     make([]float32, nSum(vertexNo)),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = util.F32Slice(reuse.w, int(nSum(vertexNo)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxUf32) Init(w float32) *AdjMxUf32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxUf32) Directed() bool <span class="cov8" title="1">{ return false }</span>

func (m *AdjMxUf32) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxUf32(vertexNo, m)
        m.Init(nan32)
}</span>

// uIdx computes the index into the weight slice of an undirected matrix
func uIdx(sz, i, j VIdx) VIdx <span class="cov8" title="1">{
        j -= i
        i = nSum(sz - i - 1)
        return i + j
}</span>

func (m *AdjMxUf32) Weight(i, j VIdx) interface{} <span class="cov0" title="0">{
        w := m.Edge(i, j)
        if math.IsNaN(float64(w)) </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return w
        }</span>
}

func (m *AdjMxUf32) SetWeight(i, j VIdx, w interface{}) <span class="cov0" title="0">{
        m.SetEdge(i, j, w.(float32))
}</span>

func (m *AdjMxUf32) Edge(i, j VIdx) (w float32) <span class="cov8" title="1">{
        if i &lt;= j </span><span class="cov8" title="1">{
                return m.w[uIdx(m.sz, i, j)]
        }</span> else<span class="cov8" title="1"> {
                return m.w[uIdx(m.sz, j, i)]
        }</span>
}

// EdgeD is used iff i &lt;= j
func (m *AdjMxUf32) EdgeD(i, j VIdx) (w float32) <span class="cov0" title="0">{
        return m.w[uIdx(m.sz, i, j)]
}</span>

func (m *AdjMxUf32) SetEdge(i, j VIdx, w float32) <span class="cov8" title="1">{
        if i &lt;= j </span><span class="cov8" title="1">{
                m.w[uIdx(m.sz, i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.w[uIdx(m.sz, j, i)] = w
        }</span>
}

// SetEdgeD is used iff i &lt;= j
func (m *AdjMxUf32) SetEdgeD(i, j VIdx, w float32) <span class="cov0" title="0">{
        m.w[uIdx(m.sz, i, j)] = w
}</span>

type AdjMxUi32 struct {
        adjMx
        w       []int32
        Cleared int32
}

func NewAdjMxUi32(vertexNo VIdx, reuse *AdjMxUi32) *AdjMxUi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                reuse = &amp;AdjMxUi32{
                        adjMx:   adjMx{sz: vertexNo},
                        w:       make([]int32, nSum(vertexNo)),
                        Cleared: i32cleared,
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.sz = vertexNo
                reuse.w = util.I32Slice(reuse.w, int(nSum(vertexNo)))
        }</span>
        <span class="cov8" title="1">return reuse</span>
}

func (m *AdjMxUi32) Init(w int32) *AdjMxUi32 <span class="cov0" title="0">{
        for i := range m.w </span><span class="cov0" title="0">{
                m.w[i] = w
        }</span>
        <span class="cov0" title="0">return m</span>
}

func (m *AdjMxUi32) Directed() bool <span class="cov8" title="1">{ return false }</span>

func (m *AdjMxUi32) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        NewAdjMxUi32(vertexNo, m)
        m.Init(m.Cleared)
}</span>

func (m *AdjMxUi32) Weight(i, j VIdx) interface{} <span class="cov0" title="0">{
        w := m.Edge(i, j)
        if w == m.Cleared </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return w
        }</span>
}

func (m *AdjMxUi32) SetWeight(i, j VIdx, w interface{}) <span class="cov0" title="0">{
        m.SetEdge(i, j, w.(int32))
}</span>

func (m *AdjMxUi32) Edge(i, j VIdx) (w int32) <span class="cov8" title="1">{
        if i &lt;= j </span><span class="cov8" title="1">{
                return m.w[uIdx(m.sz, i, j)]
        }</span> else<span class="cov8" title="1"> {
                return m.w[uIdx(m.sz, j, i)]
        }</span>
}

// EdgeD is used iff i &lt;= j
func (m *AdjMxUi32) EdgeD(i, j VIdx) (w int32) <span class="cov0" title="0">{
        return m.w[uIdx(m.sz, i, j)]
}</span>

func (m *AdjMxUi32) SetEdge(i, j VIdx, w int32) <span class="cov8" title="1">{
        if i &lt;= j </span><span class="cov8" title="1">{
                m.w[uIdx(m.sz, i, j)] = w
        }</span> else<span class="cov8" title="1"> {
                m.w[uIdx(m.sz, j, i)] = w
        }</span>
}

// SetEdgeD is used iff i &lt;= j
func (m *AdjMxUi32) SetEdgeD(i, j VIdx, w int32) <span class="cov0" title="0">{
        m.w[uIdx(m.sz, i, j)] = w
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package groph

import (
        "reflect"
)

// http://graphics.stanford.edu/~seander/bithacks.html

var wordBits uint
var wordMask uint

func init() <span class="cov8" title="1">{
        wordBits = uint(reflect.TypeOf(uint(0)).Bits())
        wordMask = wordBits - 1
}</span>

func BitSetCap(bs []uint) uint <span class="cov8" title="1">{ return uint(len(bs)) * wordBits }</span>

func BitSetGet(bs []uint, i uint) bool <span class="cov8" title="1">{
        w, b := i/wordBits, i&amp;wordMask
        return bs[w]&amp;(1&lt;&lt;b) != 0
}</span>

func BitSetSet(bs []uint, i uint) <span class="cov8" title="1">{
        w, b := i/wordBits, i&amp;wordMask
        bs[w] |= 1 &lt;&lt; b
}</span>

func BitSetUnset(bs []uint, i uint) <span class="cov8" title="1">{
        w, b := i/wordBits, i&amp;wordMask
        bs[w] &amp;= ^(1 &lt;&lt; b)
}</span>

type BitSet struct {
        Raw  []uint
        Size uint
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package groph

import (
        "reflect"
)

// VIdx is the type used to represent vertices in the graph implementations
// provided by the groph package.
type VIdx = int

// Edge represents a graphs edge between vertices I and J. For directed graphs
// its the edge from I to J.
type Edge struct {
        I, J VIdx
}

// RGraph represents a set of graph data that allows read only access to the
// egde weights.
//
// For graphs that can change edged see WGraph.
type RGraph interface {
        // VertextNo return the numer of vertices in the graph.
        VertexNo() VIdx
        // Directed returns true if the graph is a directed graph and false
        // otherwiese.
        Directed() bool
        // Returns the weight of the edge that connects the vertex with index
        // edgeFrom with the vertex with index edgeTo. If there is no such edge
        // it returns nil.
        Weight(edgeFrom, edgeTo VIdx) interface{}
}

func WeightOr(g RGraph, edgeFrom, edgeTo VIdx, or interface{}) interface{} <span class="cov0" title="0">{
        if res := g.Weight(edgeFrom, edgeTo); res != nil </span><span class="cov0" title="0">{
                return res
        }</span>
        <span class="cov0" title="0">return or</span>
}

type VisitNeighbour = func(n VIdx, fwd bool, w interface{})

// NeighbourLister is implemented by graph implementations that can easily
// iterate over all neighbous of one node.
type NeighbourLister interface {
        EachNeighbour(v0 VIdx, do VisitNeighbour)
}

func EachNeighbour(g RGraph, v VIdx, do VisitNeighbour) <span class="cov0" title="0">{
        if ln, ok := g.(NeighbourLister); ok </span><span class="cov0" title="0">{
                ln.EachNeighbour(v, do)
        }</span> else<span class="cov0" title="0"> if g.Directed() </span><span class="cov0" title="0">{
                vno := g.VertexNo()
                for n := VIdx(0); n &lt; vno; n++ </span><span class="cov0" title="0">{
                        if w := g.Weight(v, n); w != nil </span><span class="cov0" title="0">{
                                do(n, true, w)
                        }</span>
                        <span class="cov0" title="0">if w := g.Weight(n, v); w != nil </span><span class="cov0" title="0">{
                                do(n, false, w)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                vno := g.VertexNo()
                for n := VIdx(0); n &lt; vno; n++ </span><span class="cov0" title="0">{
                        if w := g.Weight(v, n); w != nil </span><span class="cov0" title="0">{
                                do(n, false, w)
                        }</span>
                }
        }
}

func CheckDirected(g RGraph) bool <span class="cov0" title="0">{
        vno := g.VertexNo()
        for i := VIdx(0); i &lt; vno; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; vno; i++ </span><span class="cov0" title="0">{
                        w1 := g.Weight(i, j)
                        w2 := g.Weight(j, i)
                        if !reflect.DeepEqual(w1, w2) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// WGraph represents a set of graph data tha allows read and write access to
// the egde weights.
type WGraph interface {
        RGraph
        // Clear resizes the graph to vertexNo and reinitializes it. Implementations
        // are expected to reuse memory.
        Clear(vertexNo VIdx)
        // SetWeight sets the edge weight for the edge starting at vertex edgeFrom
        // and ending at vertex edgeTo. Passing w==nil removes the edge.
        SetWeight(edgeFrom, edgeTo VIdx, w interface{})
}

// Clear clears a WGraph while keeping the original vertexNo.
func Clear(g WGraph) <span class="cov0" title="0">{ g.Clear(g.VertexNo()) }</span>

// RGbool represents a RGraph with boolean edge weights.
type RGbool interface {
        RGraph
        Edge(edgeFrom, edgeTo VIdx) bool
}

// WGbool represents a WGraph with boolean edge weights.
type WGbool interface {
        WGraph
        Edge(edgeFrom, edgeTo VIdx) bool
        SetEdge(edgeFrom, edgeTo VIdx, flag bool)
}

// An RGi32 is a RGraph with type safe access to the edge weight of type
// int32. Besides type safety this avoids boxing/unboxing of the Weight
// method for performance reasons.
type RGi32 interface {
        RGraph
        Edge(edgeFrom, edgeTo VIdx) (weight int32)
}

// An WGi32 is to WGraph what RGi32 is to RGraph.
type WGi32 interface {
        WGraph
        Edge(edgeFrom, edgeTo VIdx) (weight int32, exists bool)
        SetEdge(edgeFrom, edgeTo VIdx, weight int32)
        DelEdge(edgeFrom, edgeTo VIdx)
}

// An RGf32 is a RGraph with type safe access to the edge weight of type
// float32. Besides type safety this avoids boxing/unboxing of the Weight
// method for performance reasons.
type RGf32 interface {
        RGraph
        Edge(edgeFrom, edgeTo VIdx) (weight float32)
}

// An WGf32 is to WGraph what RGf32 is to RGraph.
type WGf32 interface {
        WGraph
        Edge(edgeFrom, edgeTo VIdx) (weight float32)
        SetEdge(edgeFrom, edgeTo VIdx, weight float32)
}

// CpWeights copies the edge weights from one grap to another.
// Vertices are identified by their index, i.e. the user has to take care of
// the vertex order. If the number of vertices in the graph differs the smaller
// graph determines how many edge weights are copied.
func CpWeights(dst WGraph, src RGraph) WGraph <span class="cov0" title="0">{
        sz := dst.VertexNo()
        if src.VertexNo() &lt; sz </span><span class="cov0" title="0">{
                sz = src.VertexNo()
        }</span>
        <span class="cov0" title="0">if dst.Directed() </span><span class="cov0" title="0">{
                for i := VIdx(0); i &lt; sz; i++ </span><span class="cov0" title="0">{
                        for j := VIdx(0); j &lt; sz; j++ </span><span class="cov0" title="0">{
                                w := src.Weight(i, j)
                                dst.SetWeight(i, j, w)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for i := VIdx(0); i &lt; sz; i++ </span><span class="cov0" title="0">{
                        for j := i; j &lt; sz; j++ </span><span class="cov0" title="0">{
                                w := src.Weight(i, j)
                                dst.SetWeight(i, j, w)
                        }</span>
                }
        }
        <span class="cov0" title="0">return dst</span>
}

// CpXWeights “transfers” the edge weights from src Graph to dst Graph
// with the same vertex restirctions as CpWeights. CpXWeights applies
// the transformation function xf() to each edge weight.
func CpXWeights(dst WGraph, src RGraph, xf func(in interface{}) interface{}) WGraph <span class="cov0" title="0">{
        sz := dst.VertexNo()
        if src.VertexNo() &lt; sz </span><span class="cov0" title="0">{
                sz = src.VertexNo()
        }</span>
        <span class="cov0" title="0">if dst.Directed() </span><span class="cov0" title="0">{
                for i := VIdx(0); i &lt; sz; i++ </span><span class="cov0" title="0">{
                        for j := VIdx(0); j &lt; sz; j++ </span><span class="cov0" title="0">{
                                w := src.Weight(i, j)
                                dst.SetWeight(i, j, xf(w))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for i := VIdx(0); i &lt; sz; i++ </span><span class="cov0" title="0">{
                        for j := i; j &lt; sz; j++ </span><span class="cov0" title="0">{
                                w := src.Weight(i, j)
                                dst.SetWeight(i, j, xf(w))
                        }</span>
                }
        }
        <span class="cov0" title="0">return dst</span>
}

// TODO can this be done in place?
func ReorderPath(slice interface{}, path []VIdx) <span class="cov8" title="1">{
        slv := reflect.ValueOf(slice)
        if slv.Len() == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">tmp := make([]interface{}, slv.Len())
        for i := 0; i &lt; slv.Len(); i++ </span><span class="cov8" title="1">{
                tmp[i] = slv.Index(i).Interface()
        }</span>
        <span class="cov8" title="1">for w, r := range path </span><span class="cov8" title="1">{
                v := tmp[r]
                slv.Index(w).Set(reflect.ValueOf(v))
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package test

import (
        "math"
        "math/rand"

        "git.fractalqb.de/fractalqb/groph"
)

type Point [2]float32

func Dist(p, q Point) float32 <span class="cov0" title="0">{
        d1 := p[0] - q[0]
        d2 := p[1] - q[1]
        return float32(math.Sqrt(float64(d1*d1 + d2*d2)))
}</span>

func RandomPoints(n groph.VIdx, ps []Point) []Point <span class="cov0" title="0">{
        if groph.VIdx(cap(ps)) &gt;= n </span><span class="cov0" title="0">{
                ps = ps[:n-1]
        }</span> else<span class="cov0" title="0"> {
                ps = make([]Point, n)
        }</span>
        <span class="cov0" title="0">for i := range ps </span><span class="cov0" title="0">{
                ps[i][0] = rand.Float32()
                ps[i][1] = rand.Float32()
        }</span>
        <span class="cov0" title="0">return ps</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package util

var VIdxSlice = IntSlice

func BoolSlice(s []bool, l int) []bool <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]bool, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func IntSlice(s []int, l int) []int <span class="cov8" title="1">{
        if s == nil || cap(s) &lt; l </span><span class="cov8" title="1">{
                return make([]int, l)
        }</span>
        <span class="cov8" title="1">return s[:l]</span>
}

func I32Slice(s []int32, l int) []int32 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]int32, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func UIntSlice(s []uint, l int) []uint <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]uint, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}

func F32Slice(s []float32, l int) []float32 <span class="cov0" title="0">{
        if s == nil || cap(s) &lt; l </span><span class="cov0" title="0">{
                return make([]float32, l)
        }</span>
        <span class="cov0" title="0">return s[:l]</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package mst

import (
        "errors"
        "math"
        "sort"

        "git.fractalqb.de/fractalqb/groph"
)

func sortedEdges(g groph.RGf32) (res []groph.Edge) <span class="cov8" title="1">{
        vno := g.VertexNo()
        for i := groph.VIdx(0); i &lt; vno; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; vno; j++ </span><span class="cov8" title="1">{
                        if !math.IsNaN(float64(g.Edge(i, j))) </span><span class="cov8" title="1">{
                                res = append(res, groph.Edge{i, j})
                        }</span>
                }
        }
        <span class="cov8" title="1">sort.Slice(res, func(i, j int) bool </span><span class="cov8" title="1">{
                e1, e2 := &amp;res[i], &amp;res[j]
                return g.Edge(e1.I, e1.J) &lt; g.Edge(e2.I, e2.J)
        }</span>)
        <span class="cov8" title="1">return res</span>
}

// TODO more efficient way for bookkeping of connected sets?
func retag(f map[groph.VIdx]groph.VIdx, oldTag, newTag groph.VIdx) <span class="cov8" title="1">{
        for v, t := range f </span><span class="cov8" title="1">{
                if t == oldTag </span><span class="cov8" title="1">{
                        f[v] = newTag
                }</span>
        }
}

func Kruskalf32(g groph.RGf32, mst []groph.Edge) ([]groph.Edge, error) <span class="cov8" title="1">{
        if g.Directed() </span><span class="cov0" title="0">{
                return mst, errors.New("cannot apply Kruskal's algorithm to directed graphs")
        }</span>
        <span class="cov8" title="1">mst = mst[:0]
        ebo := sortedEdges(g)
        frs := make(map[groph.VIdx]groph.VIdx)
        vc := groph.VIdx(0)
        for _, e := range ebo </span><span class="cov8" title="1">{
                ti, iOk := frs[e.I]
                tj, jOk := frs[e.J]
                if iOk </span><span class="cov8" title="1">{
                        if jOk </span><span class="cov8" title="1">{ // no new vertex
                                if ti != tj </span><span class="cov8" title="1">{
                                        retag(frs, ti, tj)
                                        mst = append(mst, e)
                                }</span>
                        } else<span class="cov8" title="1"> { // j is new vertex
                                frs[e.J] = ti
                                mst = append(mst, e)
                                vc++
                                if vc == g.VertexNo() </span><span class="cov8" title="1">{
                                        return mst, nil
                                }</span>
                        }
                } else<span class="cov8" title="1"> if jOk </span><span class="cov0" title="0">{ // i is new vertex
                        frs[e.I] = tj
                        mst = append(mst, e)
                        vc++
                        if vc == g.VertexNo() </span><span class="cov0" title="0">{
                                return mst, nil
                        }</span>
                } else<span class="cov8" title="1"> { // i &amp; j are new vertices
                        frs[e.I] = e.I
                        frs[e.J] = e.I
                        mst = append(mst, e)
                        vc += 2
                        if vc == g.VertexNo() </span><span class="cov0" title="0">{
                                return mst, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return mst, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package sp

import (
        "container/heap"
        "math"

        "git.fractalqb.de/fractalqb/groph"
        "git.fractalqb.de/fractalqb/groph/internal/util"
)

type pqItemi32 struct {
        v groph.VIdx
        p int32
}

type Dijkstrai32 struct {
        v2i []int
        is  []pqItemi32
}

func (dij *Dijkstrai32) init(vno int) <span class="cov8" title="1">{
        dij.v2i = util.IntSlice(dij.v2i, vno)
        if dij.is == nil || cap(dij.is) &lt; vno </span><span class="cov8" title="1">{
                dij.is = make([]pqItemi32, 0, vno)
        }</span> else<span class="cov8" title="1"> {
                dij.is = dij.is[:0]
        }</span>
}

func (pq *Dijkstrai32) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *Dijkstrai32) Less(i, j int) bool <span class="cov8" title="1">{
        pi, pj := pq.is[i].p, pq.is[j].p
        if pi &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if pj &lt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return pi &lt; pj</span>
}

func (pq *Dijkstrai32) Swap(i, j int) <span class="cov8" title="1">{
        ii, ij := pq.is[i], pq.is[j]
        pq.v2i[ii.v], pq.v2i[ij.v] = j, i
        pq.is[i], pq.is[j] = ij, ii
}</span>

func (pq *Dijkstrai32) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(pqItemi32)
        pq.v2i[item.v] = len(pq.is)
        pq.is = append(pq.is, item)
}</span>

func (pq *Dijkstrai32) Pop() interface{} <span class="cov8" title="1">{
        n := len(pq.is) - 1
        res := pq.is[n]
        pq.is = pq.is[:n]
        return res
}</span>

func (pq *Dijkstrai32) update(v groph.VIdx, priority int32) <span class="cov8" title="1">{
        i := pq.v2i[v]
        pq.is[i].p = priority
        heap.Fix(pq, i)
}</span>

func (dij *Dijkstrai32) On(
        g groph.RGi32,
        start groph.VIdx,
        dist []int32,
        prev []groph.VIdx,
) ([]int32, []groph.VIdx) <span class="cov8" title="1">{
        vertexNo := g.VertexNo()
        dist = util.I32Slice(dist, vertexNo)
        if prev != nil </span><span class="cov8" title="1">{
                prev = util.VIdxSlice(prev, vertexNo)
        }</span>
        <span class="cov8" title="1">dij.init(vertexNo)
        dist[start] = 0
        for v := groph.VIdx(0); v &lt; g.VertexNo(); v++ </span><span class="cov8" title="1">{
                if v != start </span><span class="cov8" title="1">{
                        dist[v] = -1
                }</span>
                <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                        prev[v] = -1
                }</span>
                <span class="cov8" title="1">heap.Push(dij, pqItemi32{v, dist[v]})</span>
        }
        <span class="cov8" title="1">for dij.Len() != 0 </span><span class="cov8" title="1">{
                u := heap.Pop(dij).(pqItemi32).v
                groph.EachNeighbour(g, u, func(n groph.VIdx, _ bool, w interface{}) </span><span class="cov8" title="1">{
                        alt := dist[u]
                        if alt &lt; 0 </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">alt += w.(int32)
                        if dist[n] &lt; 0 || alt &lt; dist[n] </span><span class="cov8" title="1">{
                                dist[n] = alt
                                if prev != nil </span><span class="cov8" title="1">{
                                        prev[n] = u
                                }</span>
                                <span class="cov8" title="1">dij.update(n, alt)</span>
                        }
                })
        }
        <span class="cov8" title="1">return dist, prev</span>
}

type pqItemf32 struct {
        v groph.VIdx
        p float32
}

type Dijkstraf32 struct {
        v2i []int
        is  []pqItemf32
}

func (dij *Dijkstraf32) init(vno int) <span class="cov8" title="1">{
        dij.v2i = util.IntSlice(dij.v2i, vno)
        if dij.is == nil || cap(dij.is) &lt; vno </span><span class="cov8" title="1">{
                dij.is = make([]pqItemf32, 0, vno)
        }</span> else<span class="cov8" title="1"> {
                dij.is = dij.is[:0]
        }</span>
}

func (pq *Dijkstraf32) Len() int <span class="cov8" title="1">{ return len(pq.is) }</span>

func (pq *Dijkstraf32) Less(i, j int) bool <span class="cov8" title="1">{ return pq.is[i].p &lt; pq.is[j].p }</span>

func (pq *Dijkstraf32) Swap(i, j int) <span class="cov8" title="1">{
        ii, ij := pq.is[i], pq.is[j]
        pq.v2i[ii.v], pq.v2i[ij.v] = j, i
        pq.is[i], pq.is[j] = ij, ii
}</span>

func (pq *Dijkstraf32) Push(x interface{}) <span class="cov8" title="1">{
        item := x.(pqItemf32)
        pq.v2i[item.v] = len(pq.is)
        pq.is = append(pq.is, item)
}</span>

func (pq *Dijkstraf32) Pop() interface{} <span class="cov8" title="1">{
        n := len(pq.is) - 1
        res := pq.is[n]
        pq.is = pq.is[:n]
        return res
}</span>

func (pq *Dijkstraf32) update(v groph.VIdx, priority float32) <span class="cov8" title="1">{
        i := pq.v2i[v]
        pq.is[i].p = priority
        heap.Fix(pq, i)
}</span>

func (dij *Dijkstraf32) On(
        g groph.RGf32,
        start groph.VIdx,
        dist []float32,
        prev []groph.VIdx,
) ([]float32, []groph.VIdx) <span class="cov8" title="1">{
        vertexNo := g.VertexNo()
        dist = util.F32Slice(dist, vertexNo)
        if prev != nil </span><span class="cov8" title="1">{
                prev = util.VIdxSlice(prev, vertexNo)
        }</span>
        <span class="cov8" title="1">dij.init(vertexNo)
        dist[start] = 0
        for v := groph.VIdx(0); v &lt; g.VertexNo(); v++ </span><span class="cov8" title="1">{
                if v != start </span><span class="cov8" title="1">{
                        dist[v] = float32(math.Inf(1))
                }</span>
                <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                        prev[v] = -1
                }</span>
                <span class="cov8" title="1">heap.Push(dij, pqItemf32{v, dist[v]})</span>
        }
        <span class="cov8" title="1">for dij.Len() != 0 </span><span class="cov8" title="1">{
                u := heap.Pop(dij).(pqItemf32).v
                groph.EachNeighbour(g, u, func(n groph.VIdx, _ bool, w interface{}) </span><span class="cov8" title="1">{
                        alt := dist[u] + w.(float32)
                        if alt &lt; dist[n] </span><span class="cov8" title="1">{
                                dist[n] = alt
                                if prev != nil </span><span class="cov8" title="1">{
                                        prev[n] = u
                                }</span>
                                <span class="cov8" title="1">dij.update(n, alt)</span>
                        }
                })
        }
        <span class="cov8" title="1">return dist, prev</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package sp

import "git.fractalqb.de/fractalqb/groph"

func FloydWarshallf32(g groph.WGf32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        if g.Directed() </span><span class="cov8" title="1">{
                for k := groph.VIdx(0); k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.VIdx(0); i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := groph.VIdx(0); j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds := g.Edge(i, k) + g.Edge(k, j)
                                        if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                for k := groph.VIdx(0); k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.VIdx(0); i+1 &lt;= vno; i++ </span><span class="cov8" title="1">{
                                for j := i + 1; j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds := g.Edge(i, k) + g.Edge(k, j)
                                        if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        }
}

func FloydWarshalli32(g groph.WGi32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        if g.Directed() </span><span class="cov8" title="1">{
                for k := groph.VIdx(0); k &lt; vno; k++ </span><span class="cov8" title="1">{
                        for i := groph.VIdx(0); i &lt; vno; i++ </span><span class="cov8" title="1">{
                                for j := groph.VIdx(0); j &lt; vno; j++ </span><span class="cov8" title="1">{
                                        ds, ok := g.Edge(i, k)
                                        if !ok </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tmp, ok := g.Edge(k, j); ok </span><span class="cov8" title="1">{
                                                ds += tmp
                                        }</span> else<span class="cov8" title="1"> {
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov8" title="1">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                for k := groph.VIdx(0); k &lt; vno; k++ </span><span class="cov0" title="0">{
                        for i := groph.VIdx(0); i+1 &lt;= vno; i++ </span><span class="cov0" title="0">{
                                for j := i + 1; j &lt; vno; j++ </span><span class="cov0" title="0">{
                                        ds, ok := g.Edge(i, k)
                                        if !ok </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if tmp, ok := g.Edge(k, j); ok </span><span class="cov0" title="0">{
                                                ds += tmp
                                        }</span> else<span class="cov0" title="0"> {
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov0" title="0">{
                                                g.SetEdge(i, j, ds)
                                        }</span>
                                }
                        }
                }
        }
}

func FloydWarshallAdjMxDf32(g *groph.AdjMxDf32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        for k := groph.VIdx(0); k &lt; vno; k++ </span><span class="cov8" title="1">{
                for i := groph.VIdx(0); i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := groph.VIdx(0); j &lt; vno; j++ </span><span class="cov8" title="1">{
                                ds := g.Edge(i, k) + g.Edge(k, j)
                                if g.Edge(i, j) &gt; ds </span><span class="cov8" title="1">{
                                        g.SetEdge(i, j, ds)
                                }</span>
                        }
                }
        }
}

func FloydWarshallAdjMxDi32(g *groph.AdjMxDi32) <span class="cov8" title="1">{
        vno := g.VertexNo()
        for k := groph.VIdx(0); k &lt; vno; k++ </span><span class="cov8" title="1">{
                for i := groph.VIdx(0); i &lt; vno; i++ </span><span class="cov8" title="1">{
                        for j := groph.VIdx(0); j &lt; vno; j++ </span><span class="cov8" title="1">{
                                ds, ok := g.Edge(i, k)
                                if !ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if tmp, ok := g.Edge(k, j); ok </span><span class="cov8" title="1">{
                                        ds += tmp
                                }</span> else<span class="cov8" title="1"> {
                                        continue</span>
                                }
                                <span class="cov8" title="1">if d, ok := g.Edge(i, j); !ok || d &gt; ds </span><span class="cov8" title="1">{
                                        g.SetEdge(i, j, ds)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package groph

import (
        "math"
)

type smpro = map[VIdx]interface{}

type SpMap struct {
        sz VIdx
        ws map[VIdx]smpro
}

var (
        _ WGraph          = (*SpMap)(nil)
        _ NeighbourLister = (*SpMap)(nil)
)

func NewSpMap(vertexNo VIdx, reuse *SpMap) *SpMap <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SpMap{
                        sz: vertexNo,
                        ws: make(map[VIdx]smpro),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.Clear(vertexNo)
                return reuse
        }</span>
}

func (g *SpMap) VertexNo() VIdx <span class="cov8" title="1">{ return g.sz }</span>

func (g *SpMap) Directed() bool <span class="cov8" title="1">{
        return true
}</span>

func (g *SpMap) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov8" title="1">{
        row, ok := g.ws[edgeFrom]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return row[edgeTo]</span>
}

func (g *SpMap) SetWeight(edgeFrom, edgeTo VIdx, w interface{}) <span class="cov8" title="1">{
        g.sz = maxSize(g.sz, edgeFrom, edgeTo)
        row, rok := g.ws[edgeFrom]
        if w == nil </span><span class="cov8" title="1">{
                if rok </span><span class="cov8" title="1">{
                        delete(row, edgeTo)
                        if len(row) == 0 </span><span class="cov8" title="1">{
                                delete(g.ws, edgeFrom)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if !rok </span><span class="cov8" title="1">{
                        row = make(smpro)
                        g.ws[edgeFrom] = row
                }</span>
                <span class="cov8" title="1">row[edgeTo] = w</span>
        }
}

func (g *SpMap) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        g.sz = vertexNo
        g.ws = make(map[VIdx]smpro)
}</span>

func (g *SpMap) EachNeighbour(v VIdx, do func(VIdx, bool, interface{})) <span class="cov0" title="0">{
        for a, ns := range g.ws </span><span class="cov0" title="0">{
                if a == v </span><span class="cov0" title="0">{
                        for b, w := range ns </span><span class="cov0" title="0">{
                                do(b, true, w)
                        }</span>
                } else<span class="cov0" title="0"> if w, ok := ns[v]; ok </span><span class="cov0" title="0">{
                        do(a, false, w)
                }</span>
        }
}

type spmrof32 = map[VIdx]float32

type SpMapf32 struct {
        sz VIdx
        ws map[VIdx]spmrof32
}

var (
        _ WGf32           = (*SpMapf32)(nil)
        _ NeighbourLister = (*SpMapf32)(nil)
)

var nan32 = float32(math.NaN())

func NewSpMapf32(vertexNo VIdx, reuse *SpMapf32) *SpMapf32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SpMapf32{
                        sz: vertexNo,
                        ws: make(map[VIdx]spmrof32),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.Clear(vertexNo)
                return reuse
        }</span>
}

func (g *SpMapf32) VertexNo() VIdx <span class="cov8" title="1">{ return g.sz }</span>

func (g *SpMapf32) Directed() bool <span class="cov8" title="1">{ return true }</span>

func (g *SpMapf32) Edge(edgeFrom, edgeTo VIdx) (weight float32) <span class="cov8" title="1">{
        row, ok := g.ws[edgeFrom]
        if !ok </span><span class="cov8" title="1">{
                return nan32
        }</span>
        <span class="cov8" title="1">weight, ok = row[edgeTo]
        if ok </span><span class="cov8" title="1">{
                return weight
        }</span> else<span class="cov8" title="1"> {
                return nan32
        }</span>
}

func (g *SpMapf32) SetEdge(edgeFrom, edgeTo VIdx, weight float32) <span class="cov8" title="1">{
        g.sz = maxSize(g.sz, edgeFrom, edgeTo)
        row, rok := g.ws[edgeFrom]
        if math.IsNaN(float64(weight)) </span><span class="cov8" title="1">{
                if rok </span><span class="cov8" title="1">{
                        delete(row, edgeTo)
                        if len(row) == 0 </span><span class="cov8" title="1">{
                                delete(g.ws, edgeFrom)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if !rok </span><span class="cov8" title="1">{
                        row = make(spmrof32)
                        g.ws[edgeFrom] = row
                }</span>
                <span class="cov8" title="1">row[edgeTo] = weight</span>
        }
}

func (g *SpMapf32) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov8" title="1">{
        tmp := g.Edge(edgeFrom, edgeTo)
        if math.IsNaN(float64(tmp)) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return tmp</span>
}

func (g *SpMapf32) SetWeight(edgeFrom, edgeTo VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                g.SetEdge(edgeFrom, edgeTo, nan32)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdge(edgeFrom, edgeTo, w.(float32))
        }</span>
}

func (g *SpMapf32) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        g.sz = vertexNo
        g.ws = make(map[VIdx]spmrof32)
}</span>

func (g *SpMapf32) EachNeighbour(v VIdx, do func(VIdx, bool, interface{})) <span class="cov0" title="0">{
        for a, ns := range g.ws </span><span class="cov0" title="0">{
                if a == v </span><span class="cov0" title="0">{
                        for b, w := range ns </span><span class="cov0" title="0">{
                                do(b, true, w)
                        }</span>
                } else<span class="cov0" title="0"> if w, ok := ns[v]; ok </span><span class="cov0" title="0">{
                        do(a, false, w)
                }</span>
        }
}

func maxSize(currentSize, newIdx1, newIdx2 VIdx) VIdx <span class="cov8" title="1">{
        if s := newIdx1 + 1; s &gt; currentSize </span><span class="cov0" title="0">{
                if newIdx2 &gt; newIdx1 </span><span class="cov0" title="0">{
                        return newIdx2 + 1
                }</span> else<span class="cov0" title="0"> {
                        return s
                }</span>
        }
        <span class="cov8" title="1">if s := newIdx2 + 1; s &gt; currentSize </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">return currentSize</span>
}

type spmroi32 = map[VIdx]int32

type SpMapi32 struct {
        sz VIdx
        ws map[VIdx]spmroi32
}

var (
        _ WGi32           = (*SpMapi32)(nil)
        _ NeighbourLister = (*SpMapi32)(nil)
)

func NewSpMapi32(vertexNo VIdx, reuse *SpMapi32) *SpMapi32 <span class="cov8" title="1">{
        if reuse == nil </span><span class="cov8" title="1">{
                return &amp;SpMapi32{
                        sz: vertexNo,
                        ws: make(map[VIdx]spmroi32),
                }
        }</span> else<span class="cov0" title="0"> {
                reuse.Clear(vertexNo)
                return reuse
        }</span>
}

func (g *SpMapi32) VertexNo() VIdx <span class="cov8" title="1">{ return g.sz }</span>

func (g *SpMapi32) Directed() bool <span class="cov8" title="1">{ return true }</span>

func (g *SpMapi32) Edge(edgeFrom, edgeTo VIdx) (weight int32, exists bool) <span class="cov8" title="1">{
        row, ok := g.ws[edgeFrom]
        if !ok </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">weight, ok = row[edgeTo]
        if ok </span><span class="cov8" title="1">{
                return weight, true
        }</span> else<span class="cov8" title="1"> {
                return 0, false
        }</span>
}

func (g *SpMapi32) SetEdge(edgeFrom, edgeTo VIdx, weight int32) <span class="cov8" title="1">{
        g.sz = maxSize(g.sz, edgeFrom, edgeTo)
        row, rok := g.ws[edgeFrom]
        if math.IsNaN(float64(weight)) </span><span class="cov0" title="0">{
                if rok </span><span class="cov0" title="0">{
                        delete(row, edgeTo)
                        if len(row) == 0 </span><span class="cov0" title="0">{
                                delete(g.ws, edgeFrom)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if !rok </span><span class="cov8" title="1">{
                        row = make(spmroi32)
                        g.ws[edgeFrom] = row
                }</span>
                <span class="cov8" title="1">row[edgeTo] = weight</span>
        }
}

func (g *SpMapi32) DelEdge(edgeFrom, edgeTo VIdx) <span class="cov8" title="1">{
        row, ok := g.ws[edgeFrom]
        if ok </span><span class="cov8" title="1">{
                delete(row, edgeTo)
        }</span>
}

func (g *SpMapi32) Weight(edgeFrom, edgeTo VIdx) interface{} <span class="cov8" title="1">{
        w, ok := g.Edge(edgeFrom, edgeTo)
        if ok </span><span class="cov8" title="1">{
                return w
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (g *SpMapi32) SetWeight(edgeFrom, edgeTo VIdx, w interface{}) <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                g.DelEdge(edgeFrom, edgeTo)
        }</span> else<span class="cov8" title="1"> {
                g.SetEdge(edgeFrom, edgeTo, w.(int32))
        }</span>
}

func (g *SpMapi32) Clear(vertexNo VIdx) <span class="cov0" title="0">{
        g.sz = vertexNo
        g.ws = make(map[VIdx]spmroi32)
}</span>

func (g *SpMapi32) EachNeighbour(v VIdx, do func(VIdx, bool, interface{})) <span class="cov0" title="0">{
        for a, ns := range g.ws </span><span class="cov0" title="0">{
                if a == v </span><span class="cov0" title="0">{
                        for b, w := range ns </span><span class="cov0" title="0">{
                                do(b, true, w)
                        }</span>
                } else<span class="cov0" title="0"> if w, ok := ns[v]; ok </span><span class="cov0" title="0">{
                        do(a, false, w)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tsp

import "git.fractalqb.de/fractalqb/groph"

// d2optU computes the difference in weight sum for a specific 2-opt operation
// that swaps e0 / e1 for undirected graphs.
func diff2optU(g groph.RGf32, p []groph.VIdx, e0, e1 groph.VIdx) (wdiff float32) <span class="cov8" title="1">{
        lenp := groph.VIdx(len(p))
        wdiff = -g.Edge(p[e0], p[e0+1])
        wdiff += g.Edge(p[e0], p[e1])
        if e1+1 == lenp </span><span class="cov8" title="1">{
                wdiff -= g.Edge(p[e1], p[0])
                wdiff += g.Edge(p[e0+1], p[0])
        }</span> else<span class="cov8" title="1"> {
                wdiff -= g.Edge(p[e1], p[e1+1])
                wdiff += g.Edge(p[e0+1], p[e1+1])
        }</span>
        <span class="cov8" title="1">return wdiff</span>
}

// d2optD computes the difference in weight sum for a specific 2-opt operation
// that swaps e0 / e1 for directed graphs.
func diff2optD(g groph.RGf32, p []groph.VIdx, e0, e1 groph.VIdx) (wdiff float32) <span class="cov8" title="1">{
        wdiff = diff2optU(g, p, e0, e1)
        for i := e0 + 1; i &lt; e1; i++ </span><span class="cov8" title="1">{
                wdiff -= g.Edge(p[i], p[i+1])
                wdiff += g.Edge(p[i+1], p[i])
        }</span>
        <span class="cov8" title="1">return wdiff</span>
}

func apply2opt(p []groph.VIdx, e0, e1 groph.VIdx) <span class="cov8" title="1">{
        e0++
        for e0 &lt; e1 </span><span class="cov8" title="1">{
                p[e0], p[e1] = p[e1], p[e0]
                e0++
                e1--
        }</span>
}

func TwoOptf32(g groph.RGf32) (path []groph.VIdx, plen float32) <span class="cov8" title="1">{
        var diff2opt func(groph.RGf32, []groph.VIdx, groph.VIdx, groph.VIdx) float32
        if g.Directed() </span><span class="cov8" title="1">{
                diff2opt = diff2optD
        }</span> else<span class="cov8" title="1"> {
                diff2opt = diff2optU
        }</span>
        <span class="cov8" title="1">vno := g.VertexNo()
        path = make([]groph.VIdx, vno)
        for i := groph.VIdx(0); i+1 &lt; vno; i++ </span><span class="cov8" title="1">{
                path[i] = i
                plen += g.Edge(i, i+1)
        }</span>
        <span class="cov8" title="1">path[vno-1] = vno - 1
        plen += g.Edge(vno-1, 0)
        for </span><span class="cov8" title="1">{
                be0, be1 := vno, vno
                bdiff := float32(0)
                for e0 := groph.VIdx(0); e0 &lt; vno; e0++ </span><span class="cov8" title="1">{
                        for e1 := e0 + 1; e1 &lt; vno; e1++ </span><span class="cov8" title="1">{
                                diff := diff2opt(g, path, e0, e1)
                                if diff &lt; bdiff </span><span class="cov8" title="1">{
                                        be0, be1 = e0, e1
                                        bdiff = diff
                                }</span>
                        }
                }
                <span class="cov8" title="1">if bdiff &lt; float32(0) </span><span class="cov8" title="1">{
                        apply2opt(path, be0, be1)
                        plen += bdiff
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
        <span class="cov8" title="1">return path, plen</span>
}

// Benchmark showed that the proformance gain is not worth it
// func (g *AdjMxDf32) Tsp2Opt() (path []uint, plen float32) {
//         vno := g.VertexNo()
//         path = make([]uint, vno)
//         for i := uint(0); i+1 &lt; vno; i++ {
//                 path[i] = i
//                 plen += g.Edge(i, i+1)
//         }
//         path[vno-1] = vno - 1
//         plen += g.Edge(vno-1, 0)
//         for {
//                 be0, be1 := vno, vno
//                 bdiff := float32(0)
//                 for e0 := uint(0); e0 &lt; vno; e0++ {
//                         for e1 := e0 + 1; e1 &lt; vno; e1++ {
//                                 diff := diff2optD(g, path, e0, e1)
//                                 if diff &lt; bdiff {
//                                         be0, be1 = e0, e1
//                                         bdiff = diff
//                                 }
//                         }
//                 }
//                 if bdiff &lt; float32(0) {
//                         apply2opt(path, be0, be1)
//                         plen += bdiff
//                 } else {
//                         break
//                 }
//         }
//         return path, plen
// }

// Benchmark showed that the proformance gain is not worth it
// func (g *AdjMxUf32) Tsp2Opt() (path []uint, plen float32) {
//         vno := g.VertexNo()
//         path = make([]uint, vno)
//         for i := uint(0); i+1 &lt; vno; i++ {
//                 path[i] = i
//                 plen += g.Edge(i, i+1)
//         }
//         path[vno-1] = vno - 1
//         plen += g.Edge(vno-1, 0)
//         for {
//                 be0, be1 := vno, vno
//                 bdiff := float32(0)
//                 for e0 := uint(0); e0 &lt; vno; e0++ {
//                         for e1 := e0 + 1; e1 &lt; vno; e1++ {
//                                 diff := diff2optU(g, path, e0, e1)
//                                 if diff &lt; bdiff {
//                                         be0, be1 = e0, e1
//                                         bdiff = diff
//                                 }
//                         }
//                 }
//                 if bdiff &lt; float32(0) {
//                         apply2opt(path, be0, be1)
//                         plen += bdiff
//                 } else {
//                         break
//                 }
//         }
//         return path, plen
// }
</pre>
		
		<pre class="file" id="file11" style="display: none">package tsp

import "git.fractalqb.de/fractalqb/groph"

func Greedyf32(m groph.RGf32) (path []groph.VIdx, plen float32) <span class="cov0" title="0">{
        size := m.VertexNo()
        switch size </span>{
        case 0:<span class="cov0" title="0">
                return nil, 0</span>
        case 1:<span class="cov0" title="0">
                return []groph.VIdx{0}, 0</span>
        }
        <span class="cov0" title="0">L := size - 1
        path = make([]groph.VIdx, size)
        // start with L → 0 → 1 → … → L
        path[L] = L
        best := m.Edge(L, 0)
        for k := groph.VIdx(0); k &lt; L; k++ </span><span class="cov0" title="0">{
                path[k] = k
                best += m.Edge(k, k+1)
        }</span>
        <span class="cov0" title="0">perm := make([]groph.VIdx, L)
        copy(perm, path)
        c := make([]groph.VIdx, L) // automatic set to 0 (go!)
        i := groph.VIdx(0)
        for i &lt; L </span><span class="cov0" title="0">{
                if c[i] &lt; i </span><span class="cov0" title="0">{
                        if (i &amp; 1) == 0 </span><span class="cov0" title="0">{
                                perm[0], perm[i] = perm[i], perm[0]
                        }</span> else<span class="cov0" title="0"> {
                                perm[c[i]], perm[i] = perm[i], perm[c[i]]
                        }</span>
                        <span class="cov0" title="0">curl := m.Edge(L, perm[0])
                        curl += m.Edge(perm[L-1], L)
                        for i := groph.VIdx(0); i+1 &lt; L; i++ </span><span class="cov0" title="0">{
                                curl += m.Edge(perm[i], perm[i+1])
                        }</span>
                        <span class="cov0" title="0">if curl &lt; best </span><span class="cov0" title="0">{
                                copy(path[:L], perm)
                                best = curl
                        }</span>
                        <span class="cov0" title="0">c[i]++
                        i = 0</span>
                } else<span class="cov0" title="0"> {
                        c[i] = 0
                        i++
                }</span>
        }
        <span class="cov0" title="0">return path, best</span>
}

func GreedyAdjMxDf32(m *groph.AdjMxDf32) (path []groph.VIdx, plen float32) <span class="cov8" title="1">{
        size := m.VertexNo()
        switch size </span>{
        case 0:<span class="cov0" title="0">
                return nil, 0</span>
        case 1:<span class="cov0" title="0">
                return []groph.VIdx{0}, 0</span>
        }
        <span class="cov8" title="1">L := size - 1
        path = make([]groph.VIdx, size)
        // start with L → 0 → 1 → … → L
        path[L] = L
        best := m.Edge(L, 0)
        for k := groph.VIdx(0); k &lt; L; k++ </span><span class="cov8" title="1">{
                path[k] = k
                best += m.Edge(k, k+1)
        }</span>
        <span class="cov8" title="1">perm := make([]groph.VIdx, L)
        copy(perm, path)
        c := make([]groph.VIdx, L) // automatic set to 0 (go!)
        i := groph.VIdx(0)
        for i &lt; L </span><span class="cov8" title="1">{
                if c[i] &lt; i </span><span class="cov8" title="1">{
                        if (i &amp; 1) == 0 </span><span class="cov8" title="1">{
                                perm[0], perm[i] = perm[i], perm[0]
                        }</span> else<span class="cov8" title="1"> {
                                perm[c[i]], perm[i] = perm[i], perm[c[i]]
                        }</span>
                        <span class="cov8" title="1">curl := m.Edge(L, perm[0])
                        curl += m.Edge(perm[L-1], L)
                        for i := groph.VIdx(0); i+1 &lt; L; i++ </span><span class="cov8" title="1">{
                                curl += m.Edge(perm[i], perm[i+1])
                        }</span>
                        <span class="cov8" title="1">if curl &lt; best </span><span class="cov8" title="1">{
                                copy(path[:L], perm)
                                best = curl
                        }</span>
                        <span class="cov8" title="1">c[i]++
                        i = 0</span>
                } else<span class="cov8" title="1"> {
                        c[i] = 0
                        i++
                }</span>
        }
        <span class="cov8" title="1">return path, best</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
